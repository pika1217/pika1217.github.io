<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[水平居中布局]]></title>
    <url>%2F2017%2F07%2F08%2FCSS%2F%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[margin:0 auto;（最常用的居中布局方式,元素宽度已知（块级元素有宽度，内联元素有内容）,未浮动，一定是用在元素本身不是父元素。父元素如果是块级元素则不用设置width默认占据一行。父元素如果是内联元素则需要display:inline-block,再设置宽度。如果是多个内联元素或者多个块级元素，则需要都放在一个块级元素里再使用此方法。因为设置完了display: inline-block 之后margin：0 auto无效了，或者直接使用第二种方法。 text-align和inline-block的结合（设置父元素的text-align为center）。这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。多个块级元素水平排列居中布局时更适合选用这种方法。 position绝对定位来实现居中布局。适用于块级元素不给出宽高的情况下(需要借助transtrom的tanslateX方法)，当又需要对多个child进行居中时需要在child外层再加一个div并对其进行定位。 #parent{ position: relative; } #child{ position: absolute; left: 50%; top: 0; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); background-color: #ccc; } 利用flex弹性布局的一个属性子元素是否有宽度不重要body{ display: flex; justify-content:center; } 浮动实现水平居中的方法12345678910111213141516171819202122232425.child&#123; float: left; position: relative; right: 50%; &#125; #part&#123; float:left; width:100%; overflow: hidden; position: relative; &#125; #part2&#123; clear: left; float: left; position: relative; left:50%; &#125; &lt;div id=&quot;part&quot;&gt; &lt;div id=&quot;part2&quot;&gt; &lt;div class=&quot;child&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;thr&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;four&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS3的fit-content实现水平居中方法居中一个浮动元素 .child{ float: left; } #part2{ width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; } 以下例子中除了第一种方式需要给宽度，其它方式都能不给宽度。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; .first-way&#123; width:100px; height: 100px; background-color: red; margin: 0 auto; &#125; .second-way&#123; width:100%; text-align: center; overflow: hidden;//实际是没有的 &#125; .second-child&#123; display: inline-block; width:100px; height:100px; background-color: red; &#125; .third-way&#123; position: absolute; left:50%; top:0%; /*默认应该是0%*/ transform:translateX(-50%); /*向左移动元素宽度的一半长度*/ width:300px; height:100px; border: 1px solid green; &#125; .fourth-way&#123; display: flex; justify-content:center; &#125; .fourth-way &gt; div&#123; width:100px; height:100px; background-color: red; &#125; .five-way&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; .five-way &gt; div&#123; float:left; width:100px; height:100px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first-way&quot;&gt; 第一种方式 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;second-way&quot;&gt; &lt;div class=&quot;second-child&quot;&gt;第二种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;third-way&quot;&gt; 第三种方式 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;fourth-way&quot;&gt; &lt;div&gt;第四种&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;/br&gt; &lt;div class=&quot;five-way&quot;&gt; &lt;div&gt; 第五种 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存作用及类型]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FWeb%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Web缓存的作用1.减少带宽消耗 2.降低服务器压力 3.减少网络时延 Web缓存的类型数据库数据缓存将查询的数据结果直接存储到内存中，下次查询时直接从内存中读取，提高响应效率。 服务器端缓存 代理服务器共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效。 CDN缓存。浏览器先向CDN边缘节点发起Web请求,若CDN节点中缓存的数据没有过期，则直接将数据返回到客户端，否则向源节点发送请求，获得数据之后更新CDN节点缓存的数据并返回到客户端 浏览器端缓存浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现 Web应用层缓存应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Web缓存类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 缓存机制]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FHTML5%20Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTML5 之离线应用Manifest 在服务器上添加MIME TYPE支，让服务器能够识别manifest后缀的文件AddType text/cache-manifest manifest 创建一个后缀名为.manifest的文件，把需要缓存的文件按格式写在里面，并用注释行标注版本 CACHE MANIFEST # 直接缓存的文件 CACHE: Path/to/cache.js # version：2012-03-20 给 标签加 manifest 属性，并引用manifest文件 离线应用访问及更新流程： 第一次访问离线应用的入口页HTML（引用了manifest文件），正常发送请求，获取manifest文件并在本地缓存，陆续拉取manifest中的需要缓存的文件再次访问时，无论在线离线与否，都会直接从缓存中获取入口页HTML和其他缓存的文件进行展示。如果此时在线，浏览器会发送请求到服务器请求manifest文件，并与第一次访问的副本进行比对，如果发现版本不一致，会陆续发送请求重新拉取入口文件HTML和需要缓存的文件并更新本地缓存副本。之后的访问重复第2步的行为 离线机制的缓存用途： 从Manifest的机制来看，即使我们不是为了创建离线应用，也同样可以使用这种机制用于缓存文件，可以说是给Web缓存提供多一种可以选择的途径。 存在的问题：缓存文件更新控制不灵活就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。 HTML5 之本地存储localstorageHTML5给我们提供本地存储localstorage特性，严格来讲，其实已经不算传统Web缓存的范畴。因为它存储的地方是跟Web缓存分开的，是浏览器重新开辟的一个地方。 localstorage的作用本地存储localstorage的作用主要使Web页面能够通过浏览器提供的set/get接口，存储一些自定义的信息到本地硬盘，并且在单次访问或以后的访问过程中随时获取或修改。 Localstorage的使用Localstorage提供了几个非常易用的Api，setItem/getItem/removeItem/clear Localstorage的缓存用途Localstorage设计的本意可能是用来存储一些用户操作的个性化设置的文本类型的信息和数据，当我们其实也可能拿来当Web缓存区使用，比如我们可以将Base64格式编码的图片信息，存在localstorage中，再次访问时，直接本地获取后，使用Css3的Data:image的方式直接展现出来。 存在的问题：大小限制按照目前标准，目前浏览器只给每个独立的域名提供5m的存储空间，当存储超过5m，浏览器就会弹出警告框。]]></content>
      <categories>
        <category>网络</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web浏览器缓存机制]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FWeb%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、浏览器的缓存规则 从新鲜度和检验值两个维度来规定浏览器是否直接使用缓存中的副本还是重新获取资源。 新鲜度(过期机制，优先级高) Expires(过期日期) Cache-Control(max-age(多少秒数后过期) no-chahe(忽略缓存的副本而向服务器发送请求) no-store(强制缓存不要保留副本并直接向服务器发送请求) 不会发送请求到服务器去验证资源的新旧程度，满足任一即可： 含有完整的过期时间控制头信息（HTTP协议报文），并且仍在有效期内 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度。 校验值(验证机制) Last-Modified（文件最后修改时间） ETag(文件标识，只要文件改变标识就会变化)(优先级高))第二次请求时会将If-Modified-Since或者If-None-Match发送给服务器验证资源的新旧程度 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需要重新获取资源内容。 二、浏览器缓存的控制使用HTML Meta标签告诉页面忽略缓存副本，每次都向服务器请求资源，缓存代理器不支持，部分浏览器不支持 使用缓存相关的HTTP消息报头1.Cahce-Control与ExpiresCache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。 2.Last-Modified/ETag与Cache-control/Expries 配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器； Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。 3.Last-Modified与ETag服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 三、哪些请求不能被缓存无法被浏览器缓存的请求： HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 经过HTTPS安全加密的请求 POST请求无法被缓存 HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
</search>