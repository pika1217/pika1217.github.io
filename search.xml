<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[输入URL发生了什么]]></title>
    <url>%2F2017%2F07%2F31%2F%E7%BD%91%E7%BB%9C%2F%E8%BE%93%E5%85%A5url%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[过程概述 浏览器查找域名对应的 IP 地址； 浏览器根据 IP 地址与服务器建立 socket 连接； 浏览器与服务器通信： 浏览器请求，服务器处理请求； 浏览器与服务器断开连接。 IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址； 域名（ DN ）：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）； DNS： 每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。 知道了上面的概念，大概就知道了想要获得服务器的门牌号码，需要先将域名转换成 IP 地址。转换过程如下（以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行）： 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询 自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求； LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址； LDNS 向 baidu.com 权限域名服务器发起请求，得到 www.baidu.com 的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 至此，浏览器已经得到了域名对应的 IP 地址。 补充说明 域名与 URL 是两个概念：域名是一台或一组服务器的名称，用来确定服务器在 Internet 上的位置；URL 是统一资源定位符，用来确定某一个文件的具体位置，例如，segmentfault.com 是 SF 的域名，根据这个域名可以找到 SF 的服务器， segmentfault.com/a/1190000003829539 是 URL ，可以根据这个 URL 定位我写的第一篇博客； IP 地址与域名不是一一对应的关系：可以把多个提供相同服务的服务器 IP 设置为同一个域名，但在同一时刻一个域名只能解析出一个 IP地址；同时，一个 IP 地址可以绑定多个域名，数量不限； 建立连接–三次握手知道了服务器的 IP 地址，下面便开始与服务器建立连接了。 通俗地讲，通信连接的建立需要经历以下三个过程： 主机向服务器发送一个建立连接的请求（ 您好，我想认识您 ）； 服务器接到请求后发送同意连接的信号（ 好的，很高兴认识您 ）； 主机接到同意连接的信号后，再次向服务器发送了确认信号（ 我也很高兴认识您 ），自此，主机与服务器两者建立了连接。 当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等； 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ； 断开连接–四次挥手主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）； 服务器接到请求后发送确认收到请求的信号（ 知道了 ）； 服务器向主机发送断开通知（ 我也该走了 ）； 主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后断开连接； 补充说明为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所有服务器先发送确认信号，等所有数据发送完毕后再同意断开。 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。 转：http://segmentfault.com/a/1190000003925803]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript常见内存泄露原因]]></title>
    <url>%2F2017%2F07%2F27%2FjavaScript%2FjavaScript%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[全局变量引起内存泄露 闭包引起内存泄露 dom清空或删除时，事件未清除导致的内存泄露 dom子元素存在引用引起内存泄露 被遗忘的定时器和回调函数(其中有引用dom节点之类的)]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式浅记]]></title>
    <url>%2F2017%2F07%2F26%2FjavaScript%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[元字符\b 代表单词的开头或结尾，也就是单词分界处 . 匹配除了换行符以外的任意字符 * 前边的内容可以连续重复使用任意次(包括0次) ，+任意次(至少1次) \bhi\b.*\bLucy\b 开头hi，中间任意字符(不包含换行) ，结尾为lucy \d 匹配一个数字 ，\d{2}匹配两个数字 ， \d{5,12} 匹配5到12位数字 \s 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等 \w 匹配字母或数字或下划线或汉字等 表1.常用的元字符代码 | 说明–|–. | 匹配除换行符以外的任意字符\w | 匹配字母或数字或下划线或汉字\s | 匹配任意的空白符\d | 匹配数字\b | 匹配单词的开始或结束^ | 匹配字符串的开始$ | 匹配字符串的结束 字符转义 \.，\*，\ 重复 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 字符[aeiou]，[.?!] [0-9]代表的含意与\d就是完全一致的：一位数字； [a-z0-9A-Z]匹配数字和大小写字母。 (?0\d{2}[) -]?\d{8}，转义字符(，能出现0次或1次(?的效果)，然后一个0，后面两个数字\d{2}，然后是）-其中一个，出现一次或者不出现(?的效果)，最后是8个数字 分支条件 |0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。 分组(\d{1,3}){3} 匹配1到3个数字重复三次 2[0-4]\d|25[0-5]|[01]?\d\d? IP地址:((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?) 反义有时需要查找不属于某个能简单定义的字符类的字符表3.常用的反义代码代码/语法 | 说明–|–\W | 匹配任意不是字母，数字，下划线，汉字的字符\S |匹配任意不是空白符的字符\D | 匹配任意非数字的字符\B | 匹配不是单词开头或结束的位置[^x] | 匹配除了x以外的任意字符[^aeiou] | 匹配除了aeiou这几个字母以外的任意字符]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程之三大模型]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2F%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B9%8B%E4%B8%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[瀑布模型方便易用，降低了软件的复杂性；但它的缺点就是在需求分析之后，用户就不再参与开发，这样导致很有可能用户的想法不能及时反映给开发人员，导致用户对产品不满，并且产品开发周期长，产品中出现的错误页很难被发现，产品和用户见面晚，这样就大大增加了返工的几率。为了避免这些问题，便有了快速原型法。 原型模型简单的说就是可以让正在开发的系统可以立刻恢复原型，这样可以及时发现错误，而且整个过程有用户和开发人员的参与，返工的几率降低，出现了错误也可以不花太多精力去改正。但是这两个模型都没有考虑到系统开发的风险。 螺旋模型这个模型可视为在每个阶段之前增加一个风险分析的原型模型，这种模型主要以风险为驱动。一般大型的系统需要考虑风险，一旦风险很大，就立刻停止当前的系统开发。 转：http://blog.csdn.net/wangdan199112/article/details/16810511]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>开发模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP与HTTPS]]></title>
    <url>%2F2017%2F07%2F25%2F%E7%BD%91%E7%BB%9C%2FHTTP%E4%B8%8EHTTPS%2F</url>
    <content type="text"><![CDATA[超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 HTTP和HTTPS的基本概念 HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 HTTP与HTTPS有什么区别？ HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 HTTPS和HTTP的区别主要如下： https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 HTTPS的工作原理 我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。 （5）Web服务器利用自己的私钥解密出会话密钥。 （6）Web服务器利用会话密钥加密与客户端之间的通信。 HTTPS的优点 尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处： （1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； （2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 （3）HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 （4）谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 HTTPS的缺点 虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的： （1）HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电； （2）HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响； （3）SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。 （4）SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。 （5）HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。 http切换到HTTPS 如果需要将网站从http切换到https到底该如何实现呢？ 这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：http://www.baidu.com改为https://www.baidu.com BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。 转: http://www.cnblogs.com/wqhwe/p/5407468.html]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP与HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie、localStorage、sessionStorage的区别]]></title>
    <url>%2F2017%2F07%2F23%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2Fcookie%E3%80%81localstorage%E3%80%81sessionstorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[cookie、localStorage、sessionStorage的区别LocalStorage（本地存储）和sessionStorage（会话存储） 是HTML5 Web Storage API 提供的，这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。 数据的生命期：cookie一般由服务器生成，在浏览器端保存，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效；localStorage除非被清除，否则永久保存；sessionStroage仅在当前会话下有效，关闭页面或浏览器后被清除; 存放数据大小:cookie:4K左右;localStorage和sessionStorage一般为5MB； 与服务器端通信：cookie每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题；localStorage和sessionStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性：cookie需要程序员自己封装，源生的Cookie接口不友好；localStorage和sessionStorage源生接口可以接受，亦可再次封装来对Object和Array有更好的支持]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie、localStorage、sessionStorage的区别]]></title>
    <url>%2F2017%2F07%2F23%2F%E7%BD%91%E7%BB%9C%2Fcookie%E3%80%81localstorage%E3%80%81sessionstorage%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[cookie、localStorage、sessionStorage的区别LocalStorage（本地存储）和sessionStorage（会话存储） 是HTML5 Web Storage API 提供的，这两种方式都允许开发者使用js设置的键值对进行操作，在在重新加载不同的页面的时候读出它们。这一点与cookie类似。 数据的生命期：cookie一般由服务器生成，在浏览器端保存，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效；localStorage除非被清除，否则永久保存；sessionStroage仅在当前会话下有效，关闭页面或浏览器后被清除; 存放数据大小:cookie:4K左右;localStorage和sessionStorage一般为5MB； 与服务器端通信：cookie每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题；localStorage和sessionStorage仅在客户端（即浏览器）中保存，不参与和服务器的通信 易用性：cookie需要程序员自己封装，源生的Cookie接口不友好；localStorage和sessionStorage源生接口可以接受，亦可再次封装来对Object和Array有更好的支持]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[juqery链式调用原理]]></title>
    <url>%2F2017%2F07%2F23%2FjavaScript%2Fjuqery%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[aQuery().init().name() 分解： a = aQuery();a.init()a.name() 把代码分解一下，很明显实现链式的基本条件就是要实例对象先创建好，调用自己的方法。 123456789aQuery.prototype = &#123; init: function() &#123; return this; &#125;, name: function() &#123; return this &#125;&#125; 所以我们如果需要链式的处理，只需要在方法内部返回当前的这个实例对象this就可以了，因为返回当前实例的this，从而又可以访问自己的原型了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。但是这种方法有一个问题是：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。 虽然Javascript是无阻塞语言，但是他并不是没阻塞，而是不能阻塞，所以他需要通过事件来驱动，异步来完成一些本需要阻塞进程的操作。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>链式调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络分层结构]]></title>
    <url>%2F2017%2F07%2F21%2F%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[七层模型OSI（Open System Interconnection，开放系统互连）七层网络模型称为开放式系统互联参考模型 ，是一个逻辑上的定义，一个规范，它把网络从逻辑上分为了7层。每一层都有相关、相对应的物理设备，比如路由器(网络层)，交换机(数据链路层)。OSI 七层模型是一种框架性的设计方法 ，建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题，其最主要的功能就是帮助不同类型的主机实现数据传输。它的最大优点是将服务、接口和协议这三个概念明确地区分开来，通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯。 应用层、表示层、会话层 (应用层)各种服务和应用程序通过该层利用网络，常用的协议有：HTTP、FTP、SMTP（邮件传输协议）;将数据包中的数据以某种协议进行解析正确展示。 传输层确认数据传输及进行纠错处理，常用的协议:TCP、UDP明确数据包将发送给某个ip地址的某个端口的进程 网络层负责数据的传输，路由及地址选择，负责将数据包传给某个ip地址。常用协议:IP、ARP（地址解析协议，根据IP地址解析出物理地址） 数据链路层(交换机、Hub)、物理层（网络接口）针对不同的物理网络的连接形式的协议，例如:Ethernet、FDDI、ATM 分层的益处建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，益处如下： 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错。 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行 能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程的区别与联系]]></title>
    <url>%2F2017%2F07%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[定义进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 关系一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 区别进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。4.优缺点 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 转:http://blog.csdn.net/yaosiming2011/article/details/44280797]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>线程与进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP2.0和HTTP1.0的差别]]></title>
    <url>%2F2017%2F07%2F20%2F%E7%BD%91%E7%BB%9C%2Fhttp2.0%E5%92%8Chttp1.0%E7%9A%84%E5%B7%AE%E5%88%AB%2F</url>
    <content type="text"><![CDATA[相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化： HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。//Frame HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。HTTP/2对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量。//HPACK 多路复用：直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。 //Stream ID Server Push：服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析HTML再发送这些请求。当客户端需要的时候，它已经在客户端了。//服务端给客户端发送一个 Frame Type 为 PUSH_PROMISE 的 Frame 并行双向字节流的请求和响应：在HTTP2.0上，实现并行双向字节流的请求和响应，客户端和服务器可以把HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。消除不必要的延迟，减少页面加载时间。注意，同一链接上有多个不同方向的数据流在传输。客户端可以一边乱序发送stream，也可以一边接收服务器的响应，而服务器那端同理。 HTTP2.0 的请求优先级：每个HTTP2.0流里面有个优先值，这个优先值确定着客户端和服务器处理不同的流采取不同的优先级策略，高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[throttle(节流)和debounce(去抖)]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2F%E9%98%B2%E6%AD%A2%E6%8A%96%E5%8A%A8javascript%E5%87%BD%E6%95%B0%E7%9A%84throttle(%E8%8A%82%E6%B5%81)%E5%92%8Cdebounce(%E5%8E%BB%E6%8A%96)%2F</url>
    <content type="text"><![CDATA[throttle预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。 123456789101112var last = 0 ; function throttle(fn,threshhold)&#123; return function()&#123; var context = this; var args = arguments; var curr = +new Date(); if(curr-last &gt; threshhold)&#123; fn.apply(context,args); last = curr; &#125; &#125; &#125; 例子: 12345678910111213141516var last = 0;function throttle(fn,delay)&#123; return (function()&#123; var context = this; var args = arguments; var curr = new Date(); if(curr - last &gt; delay)&#123; fn.apply(context,args); last = curr; &#125; &#125;)();&#125;object.onkeyup = function()&#123; throttle(search,2000);&#125;;function search()&#123;&#125; debounce当调用动作n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。 123456789101112131415timer = null; function debounce(fn,delay)&#123; clearTimeout(timer) return function()&#123; var context = this; var args = arguments; timer = setTimeout(function()&#123; fn.apply(context,args); &#125;,delay); &#125; &#125; $(&apos;input.username&apos;).keypress(debounce(function (event) &#123; // do the Ajax request &#125;, 250));]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP状态码]]></title>
    <url>%2F2017%2F07%2F18%2F%E7%BD%91%E7%BB%9C%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[类别 原因短语 1XX Informational(信息性状态码) 接受的请求正在处理 2XX Success(成功状态码) 请求正常处理完毕 3XX Redirection(重定向状态码) 需要进行附加操作以完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态码) 服务器处理请求出错 200 请求被正确处理响应报文中，随状态码一起返回的信息会因方法的不同而发生改变。 使用GET时，对应请求资源的实体会作为响应返回。 使用HEAD时，响应中只返回首部，不返回实体的主体部分。 204 返回消息为空服务器接收请求已成功处理，但返回的响应报文中不含实体的主体部分。例如浏览器发送请求处理后，返回204响应，浏览器显示页面就不发生更新。 206 返回部分内容该状态码表示客户端进行请求头中包含Range字段指定范围的请求，服务器端成功执行GET请求，响应报文中包含Content-Range指定范围的实体内容。 301 永久重定向该状态码表示请求的资源被分配了新的URI，以后应使用资源现在所指向的URI。 302 临时重定向该状态码表示请求的资源被分配了新的URI，本次应使用响应报文头部中Location所指的URI。 303 建议客户访问其他URL或访问方式该状态码表示请求对应的资源存放在另一个URI，应使用GET方法定向获取请求的资源。303状态码与302状态码有着相同的功能，但303状态码明确表示客户端应当GET方法获取资源，这与302状态码有着区别。 304 客户端已经执行了GET，但文件未变化该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源，但因发生请求未满足条件的情况，直接返回304 Not Modified，服务器端的资源未变，可直接使用客户端未过期的缓存。 307 声明请求的资源临时性删除临时重定向。该状态码与302 Found有着相同含义。但不会指定客户端的重定向的请求方法。 400 错误请求，如语法错误该状态码表示请求报文中存在语法错误。当错误发生时，需要修改请求的内容后再次发送请求。 401 请求授权失败该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。 403 请求不被允许该状态码表明对请求资源的访问被服务器拒绝了 404 没有发现资源该状态码表示服务器上无法找到请求的资源。 500该状态码表明服务器在执行请求时发生了错误 503该状态码表明服务器暂时处于超负荷或正在进行停机维护，现在无法处理请求]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预加载和懒加载]]></title>
    <url>%2F2017%2F07%2F18%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2F%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[懒加载什么是懒加载在页面中先把img或其他元素的背景图片用1*1px的图片占位，只有当图片出现在浏览器的可视区域内时，才设置图片真正的路径，让图片显示出来。这就是图片懒加载。 为什么使用懒加载页面内容较多，一次性加载需要较长时间，优化用户体验 原理 页面中的img元素，如果没有src属性，浏览器就不会发出请求去下载图片，只有通过JavaScript设置了图片路径，浏览器才会发送请求。 懒加载的原理就是先在页面中把所有的图片统一使用一张占位图进行占位，把真正的路径存在元素的“data-url”属性里，要用的时候就取出来，再设置； 实现当需要展示内容时将data-url中的属性值替换url属性，就能下载图片；触发加载的条件： 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟，如果用户在加载前就离开了页面，那么就不会加载。 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离就开始加载，这样能保证用户拉下时正好能看到图片。 获取浏览器窗口的高度： 1seeHeight = document.documentElement.clientHeight||document.body.clientHeight; 获取滑动条距离顶部的高度(即页面向上滑动的距离)： 1scrollTop = document.documentElement.scrollTop || document.body.scrollTop; 获取需要懒加载的图片到文档头部的距离 1offsetTop = element.offsetTop 123456789js: if(offsetTop &lt; seeHeight+scrollTop)&#123; //加载 &#125; Jquery： if($(element).offset().top &lt; $(window).height()+$(document).scrollTop())&#123; //加载 &#125; 优点页面加载速度快、可以减轻服务器的压力、节约了流量,用户体验好 问题1.来回滚动下拉条，不要立即向服务器发送请求，监听滚动事件，延迟执行，如果在执行之前又触发则清除之前的定时器，重新设置定时器 2.加载过的图像就不需要重复加载，可以给加载过得图像一个属性，标志其已经加载过，下次就不用加载。 预加载定义提前加载图片，当用户需要查看时可直接从本地缓存中渲染 意义保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。 方法 使用CSS和javascript实现预加载 123#preload-01 &#123; background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; &#125; #preload-02 &#123; background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; &#125; #preload-03 &#123; background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; &#125; 这样图片会和其它内容一起加载，改进：在加载了其它内容之后再预加载图片 123456789101112131415161718192021function preloader() &#123; if (document.getElementById) &#123; document.getElementById(&quot;preload-01&quot;).style.background = &quot;url(http://domain.tld/image-01.png) no-repeat -9999px -9999px&quot;; document.getElementById(&quot;preload-02&quot;).style.background = &quot;url(http://domain.tld/image-02.png) no-repeat -9999px -9999px&quot;; document.getElementById(&quot;preload-03&quot;).style.background = &quot;url(http://domain.tld/image-03.png) no-repeat -9999px -9999px&quot;; &#125; &#125; function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; if (oldonload) &#123; oldonload(); &#125; func(); &#125; &#125; &#125; addLoadEvent(preloader); 仅使用javaScript实现预加载 123456789101112131415161718192021222324function preloader() &#123; if (document.images) &#123; var img1 = new Image(); var img2 = new Image(); var img3 = new Image(); img1.src = &quot;http://domain.tld/path/to/image-001.gif&quot;; img2.src = &quot;http://domain.tld/path/to/image-002.gif&quot;; img3.src = &quot;http://domain.tld/path/to/image-003.gif&quot;; &#125; &#125; function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != &apos;function&apos;) &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; if (oldonload) &#123; oldonload(); &#125; func(); &#125; &#125; &#125; addLoadEvent(preloader); 使用Ajax实现预加载 12345678910111213window.onload = function() &#123; setTimeout(function() &#123; // XHR to request a JS and a CSS var xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.js&apos;); xhr.send(&apos;&apos;); xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, &apos;http://domain.tld/preload.css&apos;); xhr.send(&apos;&apos;); // preload image new Image().src = &quot;http://domain.tld/preload.png&quot;; &#125;, 1000); &#125;; 懒加载和预加载的对比1)概念： 懒加载也叫延迟加载：js图片延迟加载,延迟加载图片或符合某些条件时才加载某些图片。 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 2)区别：两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 3)懒加载的意义及实现方式有： 意义：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 实现方式： 第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟. 第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。 第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。 4)预加载的意义及实现方式有：意义:预加载可以说是牺牲服务器前端性能，换取更好的用户体验，这样可以使用户的操作得到最快的反映。 实现方式：实现预载的方法非常多，比如：用CSS和JavaScript实现预加载；仅使用JavaScript实现预加载；使用Ajax实现预加载。常用的是new Image();设置其src来实现预载，再使用onload方法回调预载完成事件。只要浏览器把图片下载到本地，同样的src就会使用缓存，这是最基本也是最实用的预载方法。当Image下载完图片头后，会得到宽和高，因此可以在预载前得到图片的大小(方法是用记时器轮循宽高变化)。 补充知识屏幕可视窗口大小 1234567891011原生方法： window.innerHeight 标准浏览器及IE9+ || 一般不会用 document.documentElement.clientHeight 标准浏览器及低版本IE标准模式 || document.body.clientHeight 低版本混杂模式 jQuery方法： $(window).height(); 浏览器窗口顶部与文档顶部之间的距离，也就是滚动条滚动的距离： 1234567891011原生方法： window.pagYoffset 标准浏览器及IE9+ || 一般不会用 document.documentElement.scrollTop 兼容ie低版本的标准模式 || document.body.scrollTop 兼容混杂模式； jQuery方法： $(document).scrollTop(); 获取元素的尺寸: 1234$(o).width() = o.style.width;$(o).innerWidth() = o.style.width+o.style.padding;$(o).outerWidth() = o.offsetWidth = o.style.width+o.style.padding+o.style.border；$(o).outerWidth(true) = o.style.width+o.style.padding+o.style.border+o.style.margin； 注意 要使用原生的style.xxx方法获取属性，这个元素必须已经有内嵌的样式，如&lt;div style=&quot;....&quot;&gt;&lt;/div&gt;； 如果原先是通过外部或内部样式表定义css样式，必须使用o.currentStyle[xxx] || document.defaultView.getComputedStyle(0)[xxx]来获取样式值。 获取元素的位置信息 jQuery： $(o).offset().top = o.style.offsetTop 元素距离文档顶的距离 $(o).offset().left 元素距离文档左边缘的距离。 原生：this.offsetTop; (此属性可以获取元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离。 while (obj) { h += obj.offsetTop; obj = obj.offsetParent; } ) 顺便提一下返回元素相对于第一个以定位的父元素的偏移距离，注意与上面偏移距的区别； jquery：position()返回一个对象 $(o).position().left = o.style.left;&lt;/code&gt;&lt;br&gt;&lt;code&gt;$(o).position().top = o.style.top； 参考: http://www.jianshu.com/p/4876a4fe7731]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝和浅拷贝]]></title>
    <url>%2F2017%2F07%2F17%2FjavaScript%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[基本理解对于基本类型的值来说，深、浅复制就是对值得复制，变量之间不会相互影响。 对于对象类型的值来说，浅复制就是复制了对象的地址，并没有开辟新的堆，复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，另一个对象的该属性也会随之改变；而深复制则是开辟新的堆区(真正的内容存放在堆上)，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 基本类型和引用类型存放的区别 基本类型的数值存放在栈区,变量–数值，比较的时候直接比较数值，深浅复制之后基本类型变量对应的数值都是相同的，但是又新的栈开辟。 引用类型的数值存放在堆区，变量–地址–内容，比较时比较的是地址，浅复制之后引用类型变量对应的数值（地址）是相同的，但是深复制之后变量对应的数值（地址）是不同的，有新的堆被开辟 方法通过递归进行深复制1234567891011121314151617181920212223242526272829var china = &#123; nation : &apos;中国&apos;, birthplaces:[&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;], skincolr :&apos;yellow&apos;, friends:[&apos;sk&apos;,&apos;ls&apos;], say:function()&#123; console.log(8); &#125; &#125;var clone_china = china;//浅复制function deepCopy(srcObject,dstObject)&#123; var dstObject = dstObject || &#123;&#125;; for(var i in srcObject)&#123; if(typeof(srcObject[i]) === &apos;object&apos;)&#123; if(resObject[i].constructor === Array)&#123; dstObject[i] = []; &#125;else&#123; dstObject[i] = &#123;&#125;; &#125; deepCopy(srcObject[i],dstObject[i]); &#125;else&#123; dstObject[i] = srcObject[i]; &#125; &#125;&#125;var result = &#123;name:&apos;result&apos;&#125;//如果复制目标有这个属性则会被替换，没有则会保留result = deepCopy(china,result);//深复制 通过JSON进行深复制123456789101112131415161718var test =&#123; name:&#123; xing:&#123; first:&apos;张&apos;, second:&apos;李&apos; &#125;, ming:&apos;老头&apos; &#125;, age :40, friend :[&apos;隔壁老王&apos;,&apos;宋经纪&apos;,&apos;同事&apos;] &#125; var result = JSON.parse(JSON.stringify(test))//深复制 result.age = 30 result.name.xing.first = &apos;王&apos; result.friend.push(&apos;fdagldf;ghad&apos;) console.dir(test) console.dir(result) Jquery 浅拷贝（false 默认）：如果第二个参数对象有的属性第一个参数对象也有，那么不会进行相同参数内部的比较，直接将第一个对象的相同参数覆盖。 深拷贝（true）：如果第二个参数对象有的属性第一个参数对象也有，还要继续在这个相同的参数向下一层找，比较相同参数的对象中是否还有不一样的属性，如果有，将其继承到第一个对象，如果没有，则覆盖。1234567891011121314151617181920212223242526272829var object1 = &#123; apple: 0, banana: &#123; weight: 52, price: 100 &#125;, cherry: 97&#125;;var object2 = &#123; banana: &#123; price: 200 &#125;, durian: 100&#125;;//默认情况浅拷贝//$.extend(object1, object2);//object1---&gt;&#123;&quot;apple&quot;:0,&quot;banana&quot;:&#123;&quot;price&quot;:200&#125;,&quot;cherry&quot;:97,&quot;durian&quot;:100&#125;//object2的banner覆盖了object1的banner，但是weight属性未被继承//深拷贝$.extend(true,object1, object2);//object1---&gt;&#123;&quot;apple&quot;:0,&quot;banana&quot;:&#123;&quot;weight&quot;:52,&quot;price&quot;:200&#125;,&quot;cherry&quot;:97,&quot;durian&quot;:100&#125;//object2的banner覆盖了object1的banner，但是weight属性也被继承了console.log(&apos;object1---&gt;&apos;+JSON.stringify(object1));]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>深拷贝和浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优雅降级 渐进增加]]></title>
    <url>%2F2017%2F07%2F17%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2F%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%20%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[优雅降级和渐进增强之前在看一些css3效果demo的时候，发现有些写css3属性时，兼容性的写法顺序不太一样，比如transition属性，有些把transition放在前面有些是放在后面，当然这也有可能包含了coder个人的习惯或是强迫性，比如下面这两种： 1234567891011121314//渐进增强.transition&#123; -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s; &#125;//优雅降级.transition&#123; transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s; &#125; transition放在前面还是后面却引申了两个概念：优雅降级和渐进增强。 优雅降级和渐进增强印象中是随着css3流出来的一个概念。由于低级浏览器不支持css3，但css3的效果又太优秀不忍放弃，所以在高级浏览中使用css3而低级浏览器只保证最基本的功能。咋一看两个概念差不多，都是在关注不同浏览器下的不同体验，关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。 定义与区别渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 优雅降级“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 渐进增强“渐进增强”观点则认为应关注于内容本身。内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 转:http://www.cnblogs.com/mofish/p/3822879.html]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆栈的区别]]></title>
    <url>%2F2017%2F07%2F16%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F%E5%A0%86%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[堆栈空间分配栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表 堆栈缓存方式栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 堆栈数据结构区别堆（数据结构）：堆可以被看成是一棵树，如：堆排序。栈（数据结构）：一种先进后出的数据结构。 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小。 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。 对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列。 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向； 对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。 分配方式：堆都是动态分配的，没有静态分配的堆。 栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较 高。 堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。 转: http://www.cnblogs.com/mysticCoder/p/4921724.html]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5适配移动端]]></title>
    <url>%2F2017%2F07%2F16%2Fhtml%2FHTML5%E9%80%82%E9%85%8D%E7%A7%BB%E5%8A%A8%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[主流的四种方法CSS3媒体查询定义媒体查询可以让我们根据设备显示器的特性（如视口宽度、屏幕比例、设备方向：横向或纵向）为其设定CSS样式，媒体查询由媒体类型和一个或多个检测媒体特性的条件表达式组成。媒体查询中可用于检测的媒体特性有 width 、 height 和 color （等）。使用媒体查询，可以在不改变页面内容的情况下，为特定的一些输出设备定制显示效果。 位置媒体查询写在CSS样式代码的最后，CSS是层叠样式表，在同一特殊性下，靠后的的样式会重叠前面的样式 写法1234567891011121314151617@media screen and (max-width:720px) and (min-width:320px)&#123; body&#123; background-color:red; &#125;@media screen and (max-width:320px)&#123; body&#123; background-color:blue; &#125;&#125; 该段媒体查询的意思是：当设备屏幕宽度在320px——720px之间时，媒体查询中body的背景色（background-color:red;）会重叠之前的body背景色，当设备屏幕宽度在320px以下时，媒体查询中body的body背景色（background-color:blue;）会重叠之前的body背景色 百分比适配用百分比做适配的方法是子元素相对于父元素的百分之多少，比如父元素的宽度为100px;设置子元素的宽度可为60%;这时子元素的宽为60px;如父元素的宽度改为200px时，这时子元素的宽就是120px; 所以可将body默认宽度设置为屏幕宽度（PC中指的是浏览器宽度），子孙元素按百分比定位（或指定尺寸）就可以了，这只适合布局简单的页面，复杂的页面实现很困难。 使用meta标签12345&lt;meta name=&quot;viewport content=&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;/&gt;width=device-width:宽度等于当前设备的宽度initial-scale=1：初始的缩放比例（默认为1）maximum-scale=1：允许用户缩放到得最大比例（默认为1）user-scalable=no：用户不能手动缩放 使用rem来做适配使用方法： 1、JS方法 12345var html = document.querySelector(‘html‘);var rem = html.offsetWidth / 7.5;html.style.fontSize = rem + “px”; 2、CSS方法 在根元素(html)中定义了一个基本字体大小为62.5%（也就是10px。设置这个值主要方便计算，如果没有设置，将是以“16px”为基准 ）。 12345html &#123;font-size: 62.5%;/*10 ÷ 16 × 100% = 62.5%*/&#125;body &#123; font-size: 1.4rem; /*1.4 × 10px = 14px */&#125;h1 &#123;font-size: 2.4rem; /*2.4 × 10px = 24px*/&#125;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5适配移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化方案]]></title>
    <url>%2F2017%2F07%2F16%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[使用CDN【内容分发网络】加速定义CDN【Content Delivery Network】，即内容分发网络。属于http缓存技术中的一种。 原理其基本思路是尽可能的避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输更快、更稳定。通过在网络各处放置节点服务器所构成的现有互联网基础之上的一层虚拟网络，CDN系统能够实时的根据网络流量和各节点的连接，负载状况以及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的就是使用户能够就近的获取请求数据，解决网络访问拥挤状况，提高用户访问系统的响应时间。管理分布在多个地理位置上的服务器，其系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重定向到一个能提供最好用户体验的服务节点上。它位于网络的边缘，据用户仅“一跳”之隔。代理缓存提供数据中心服务器的一个镜像，当用户对某网址访问的请求并非第一次，那么代理缓存在很大概率上缓存了域名，就不需要大费周章通过DNS【域名服务系统】来获取对应域名。 减少http请求【减少请求数，降低请求量】脚本合并原理通常一个大型网站需要依赖多个JS文件。可以把多个文件合并成一个，这样只需要引用一个文件 1.Grunt 2. JSCompress CSS雪碧图优点: 减少http请求，提高页面加载速度。只需加载一张图片，且由于只需要一个对应的色表，这张图片的大小很可能比拼合前的总尺寸小。 减少鼠标滑过的bug：IE6不会主动预加载：hover中的背景图片，因此使用多张图片时会出现闪白的现象。缺点: 最大的问题是内存的使用：除非非常小心的组织，否则会留下大量无用的空白。 影响页面缩放功能：缩放时要避免雪碧中相邻图片露出来。 文件压缩包括CSS、JavaScript、图片的压缩。 JavaScript： 最小化：删除注释和空格等不必要的字符。安全、直白，文件减少21%。 混淆：删除注释和空格，将函数名和变量名替换成短的字符串，难于反向工程。复杂，容易产生问题，文件减少25%。 方法: JSMin YUI Compressor在线 在线JS/CSS/HTML压缩 JavaScript压缩/解压缩 grunt 批量图片压缩 压缩HTTP响应内容:Gzip 延迟加载图片【Lazy Load Images】首先只加载第一屏的图片，当用户滚动访问后面的内容时在加载相应图片。方法：将图片的src属性值存放在一个非src的自定义属性中，判断图片进入可视区域后将路径赋值给src属性。 CSS3图标iconfont公开图标库Font Awesome 避免重定向301：永久重定向，抓取新内容的同时也将旧的网址替换为重定向之后的网址； 302：暂时重定向，抓取新的内容而保留旧的网址 SEO：302好于301 重定向会增加http请求数，但必要的重定向有利于提高用户体验 方法： 定义链接URL时使用最完整的、最直接的地址。如： 使用www.baidu.com而非baidu.com 在使用Response.Redirect的时候，设置第二个参数为false. 代码优化减少对DOM的操作对DOM的操作代价是昂贵的，这在网页中通常是一个性能瓶颈。减少对DOM元素的查询与修改： 查询：需多次访问的可以保存在变量中。 修改：使用innerHTML代替DOM操作。 减少重排与重绘原理：页面生成时会进行至少一次渲染，用户访问过程中还可能不停地重新渲染。情况如下： 修改DOM，修改样式表，用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）重新渲染，就需要重新生成布局和重新绘制。前者叫做“重排【reflow】”，表现为页面布局出现变动。后者叫做“重绘【repaint】”。“重绘”不一定需要“重排”，如改变元素颜色，因为此时页面布局并未发生改变；而“重排”一定会导致“重绘”，布局的变化会同时触发“重排”和“重绘”。“重排”和“重绘”均会使性能下降，因此要尽量避免。 一般规则：样式表越简单，重排和重绘就越快；重排和重绘的DOM元素层级越高，成本越高；table元素的重排和重绘成本高于div元素。 优化方法 通过class改变样式，避免逐条改变； 对display：none的元素操作不会引发重排和重绘，因此需要多次操作的元素可改变其display属性再进行操作，完成操作后再将其显示，这样只需要两次重排和重绘；另外，visibility：hidden的元素操作只重绘； 脱离文档流的元素重排开销较小【如：position为absolute或fixed，float元素】，因为对文档流中元素无影响； 避免CSS表达式CSS表达式会进行大量重复计算，甚至当鼠标在页面移动时也在不停执行，这大大影响性能。尽量使用一次性表达式，避免动态计算。 缓存Ajax例如jQuery中的Ajax中cache:trueAjax缓存和http缓存效果相同。Ajax页面缓存是ajax处理数据时对一些重复相同数据进行一个缓存操作，这种设计使客户端对一些静态页面内容的请求，比如图片，css文件，js脚本等，变得更加快捷，提高了页面的响应速度，也节省了网络通信资源。 yahoo军规35条]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标准模式和怪异模式的区别]]></title>
    <url>%2F2017%2F07%2F15%2FCSS%2F%E6%A0%87%E5%87%86%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%80%AA%E5%BC%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[怪异模式和标准模式W3c标准出台之前，各浏览器对页面的渲染方式不统一，即有怪异模式。当W3c标准推出之后，不同浏览器对页面的渲染有统一的标准，即标准模式。 何时触发怪异模式和标准模式在标准模式中，浏览器根据规范呈现页面；在混杂模式中，页面以一种比较宽松的向后兼容的方式显示。如果XHTML文档包含形式完整的DOCTYPE，那么它一般以标准模式呈现。对于HTML 4.01文档，包含严格DTD的DOCTYPE常常导致页面以标准模式呈现。包含过渡DTD和URI的DOCTYPE也导致页面以标准模式呈现，但是有过渡DTD而没有URI会导致页面以混杂模式呈现。DOCTYPE不存在或形式不正确会导致HTML和XHTML文档以混杂模式呈现。IE中，如果doctype声明在xml之后，会导致怪异模式 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; 区别1）在严格模式中 ：width是内容宽度 ，元素真正的宽度 = border+padding+ width； 在怪癖模式中 ：width则是元素的实际宽度 ，内容宽度 = width - ( padding-left + padding-right + border-left-width + border-right-width) 2）设置行内元素的高宽 在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。 3）设置百分比的高度 在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。而在quirks模式下，则会生效。 4）用margin:0 auto设置水平居中在IE下会失效 使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效,quirk模式下的解决办法，用text-align属性:body{text-align:center};#content{text-align:left} 5）quirk模式下设置图片的padding会失效 6）quirk模式下Table中的字体属性不能继承上层的设置 7）quirk模式下white-space:pre会失效 http://blog.csdn.net/xujie_0311/article/details/42044277]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浏览器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data*属性用法]]></title>
    <url>%2F2017%2F07%2F15%2Fhtml%2Fdata-%E5%B1%9E%E6%80%A7%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原生Js中data属性使用方法读、写属性 直接在HTML元素中写： Click Here 通过Js来操作：var test = document.getElementById(‘test’);test.dataset.my = ‘Byron’; HTML5中元素都会有一个dataset的属性，这是一个DOMStringMap类型的键值对集合，这个属性中只包含那些带data-*属性,使用Js对其添加和读取操作有注意: 获取自定义属性时去掉前缀data- 属性名称中含有连字符时使用驼峰命名法（在HTML中自动转换成连字符形式），但是在CSS属性选择器中使用连字符形式。 getAttribute、setAttribute与自定义属性关系 自定义属性也能通过get、setAttribute方式读写，test.setAttribute(‘data-age’,25);test.getAttribute(‘data-age’) dataset只是attribute的一个子集，get、setAttribute可以操作所有的dataset内容。 浏览器兼容性Internet Explorer 11+ Chrome 8+ Firefox 6.0+ Opera 11.10+ Safari 6+ Jquery操作data属性读取操作$(this).data(‘key’,value)、$(this).data(‘key’),去掉data-前缀，对应的是$(this).attr() data属性不仅能存基本类型的数值，还能存对象，JSon等等形式的数据。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>data*属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边界塌陷]]></title>
    <url>%2F2017%2F07%2F15%2FCSS%2F%E8%BE%B9%E7%95%8C%E5%A1%8C%E9%99%B7%2F</url>
    <content type="text"><![CDATA[边界塌陷主要是在并列div和父div包含子div两种情况并列div上面div的margin-bottom和下面div的margin-top会出现塌陷，也就是会取两者之间的最大值显示。上述代码中test1和test2的间距是10px,而不是15px,而且注意此处的边界塌陷并不是说div边界重合，当重合时是因为上下div没有设置margin的值，此处说的的边界塌陷是上下div的margin总和不是单纯相加，而是取上下margin的最大值; 父div包含子div对于有块级子元素的父元素计算高度的方式,如果元素没有垂直边框和填充,那其高度就是其子元素顶部和底部边框边缘之间的距离，也就是会使得父子元素的top相互重合,不过只针对第一个子元素test1，test2设置margin-top就不会出现塌陷。 出现原因： 两个或多个边距没有被非空内容，padding（父），border（父），overflow（父）分隔开； 处于文档流中(float和absoluate的元素不会） 解决办法： 设置父元素或子元素float属性或者position:absolute 在父元素中添加内容 给父元素设置padding，border或者over-flow属性 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .main&#123; width: 200px; height: 200px; background: red; margin-top: 30px; &#125; .test1&#123; width: 100px; height: 100px; background: #000; margin-top: 10px; margin-bottom: 5px; &#125; .test2&#123; width: 100px; height: 100px; background-color: green; margin-top: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;test1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;test2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>边界塌陷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[post与get的区别]]></title>
    <url>%2F2017%2F07%2F14%2F%E7%BD%91%E7%BB%9C%2Fpost%E4%B8%8Eget%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被存为书签，而POST不可以。 GET请求会被浏览器主动cache，而POST不会。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 上述大多数区别都是基于第九条从而提出的。然而post与get其实并无本质区别！post和get都是HTTP请求的基本方法，其中还有put和delete方法，由于HTTP协议是基于TCP/IP关于数据如何在万维网中传输的协议，所以put和get方法都是基于TCP/IP协议的方法，都是基于TCP连接，理论和技术上都能使用url或者request body 传递参数。但是HTTP规定这两种方法传参方式的不同以及对于参数长度的限制肯定有它的道理：如果用get方法并在request body中传递参数，有些服务器会读取数据，有些会直接忽略，所以get方法参数一般放在url中。不同浏览器和服务器对数据处理的能力不同。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url，post方法参数长度是没有限制的，起限制作用的是服务器的处理程序的处理能力。 真正的区别在于GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 然而 GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>post与get的区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply、bind]]></title>
    <url>%2F2017%2F07%2F14%2FjavaScript%2Fcall%E3%80%81apply%E3%80%81bind%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[call，apply，bind这三个方法其实都是继承自Function.prototype中的，属于实例方法。如果call,apply方法没有参数，或者参数为null或undefined或者this，则等同于指向全局对象 区别 方法 是否直接执行函数 传入的参数 调用方式 call 是 (context,arg1,arg2,arg3…) 第二个参数之后都是实参 function.call(context,arg1,arg2,arg3…) apply 是 (context,[arg1,arg2,arg3…])第二个参数必须是数组 function.apply(context,[arg1,arg2,arg3…]) bind 否 (context)只有一个参数 var newFunction = function.bind(context);newFunction(arg1,arg2,arg3…) a：第一个参数都是指定函数内部中this的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。 b：都可以在函数调用时传递参数。call，bind方法需要直接传入，而apply方法需要以数组的形式传入。 c：call，apply方法是在调用之后立即执行函数，而bind方法没有立即执行，需要将函数再执行一遍。 实例：1、call 12var a = &#123;x: 1&#125;; var b = function (y, z) &#123; console.log(this.x + y + z) &#125;; b.call(a, 3, 4);//此时b的this（即b执行时的上下文）被改变为a，因此this.x为1，第二个参数之后都是传给b实参。 2、apply 12var a = &#123;x: 1&#125;; var b = function (arr) &#123; console.log(this.x + arr[0] + arr[1]) &#125;; b.call(a, [3, 4]);//此时b的this（即b执行时的上下文）被改变为a，第二个参数是一个数组 3、bind 12var a = &#123;x: 1&#125;; var b = function (y, z) &#123; console.log(this.x + y + z) &#125;; var newB = b.bind(a);//此时b的this（即b执行时的上下文）被改变为a，由此生成一个新函数，函数不会立即执行。 newB(3, 4);//函数此时才执行 常用场景1、数组之间追加 1var array1 = [12, &quot;foo&quot;, &#123;name: &quot;Joe&quot;&#125;, -2458]; var array2 = [&quot;Doe&quot;, 555, 100]; Array.prototype.push.apply(array1, array2); /* array1 值变为 [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100] */ View Code 2、获取数组中的最大值和最小值 1var numbers = [5, 458, 120, -215]; var maxInNumbers = Math.max.apply(Math, numbers); //458 View Code 3、验证是否是数组（前提是toString()方法没有被重写过） 1function isArray(obj)&#123; return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;; &#125; 原生的Object.prototype.toString()与数组的toString()方法是有区别的，数组（引用）是继承Object，也是通过Object.prototype实现的，而toString（）就是Object.prototype中自带的方法，理论上会被Array对象继承，然而Array.prototype重写了toString（）方法，数组调用toString（）会返回逗号连接成的字符串。RegExp类型以及Date类型的toString()方法都被重写 4、类（伪）数组使用数组方法 1var domNodes = Array.prototype.slice.call(document.getElementsByTagName(&quot;*&quot;)); 5、数字求和 1function sum() &#123; var numberSum = Array.prototype.reduce.apply(arguments, [function (prev, next) &#123; return prev + next; &#125;]); console.log(numberSum); &#125; sum(1, 2, 3); jQuery中$.type()函数判断对象类型的实现就是如下，通过Object.prototype.toString.call()返回[object,class],再截取出class 1234function type(boj)&#123; return Object.prototype.toString.call(boj).slice(8,-1);&#125; 在toString(this)方法被调用时,会执行下面的操作步骤: 如果this的值为undefined,则返回&quot;[object Undefined]&quot;. 如果this的值为null,则返回&quot;[object Null]&quot;. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 返回三个字符串&quot;[object &quot;, class, 以及 &quot;]&quot;连接后的新字符串. 参考： http://www.cnblogs.com/EnSnail/p/6687491.html https://www.zhihu.com/question/40892203/answer/93261099 http://www.cnblogs.com/libin-1/p/5823025.html]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>call、apply、bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2017%2F07%2F13%2FjavaScript%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[原型链 利用原型让一个引用类型继承另一个引用类型的属性和方法 12345678910function SuperType()&#123; this.property = true; &#125; SuperType.prototype.getSuperValue = function()&#123; return this.property; &#125; function SubType()&#123; this.subproperty = false; &#125; SubType.prototype = new SuperType(); // 这句不可以使用对象字面量创建原型，因为此时原型是一个Object对象的实例，切断了与SuperType的联系 12345SuperType.prototype.getSubValue = function()&#123; //给原型添加方法要在替换原型语句之后 return this.subproperty; &#125;var instance = new SubType();alert(instance.getSuperValue()); //true 实例和原型之间的关系可以用instanceof来确定 instance instanceof SubType 还可以用 isPrototypeOf来确定 SubType.prototype.isPrototypeOf(instance) 原型链的问题： 包含引用类型值的原型属性会被所有实例共享，而这也正是为什么要在构造函数中而不是原型对象中定义属性的原因，继承后原型会变成另一个类型的实例，原先的实例属性也就顺理成章地变成现在的原型属性了。 在创建子类型的实例时，不能向超类型的构造函数中传递参数，没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 123456789101112131415function SuperType()&#123; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;function SubType()&#123;&#125;SubType.prototype = new SuperType();var instance1 = new SubType();instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;var instance2 = new SubType();alert(instance2.colors); //&quot;red,blue,green,black&quot;color属性包含一个数组（引用类型值），SuperType的每个实例会有各自的color属性，SubType.prototype变成SuperType的一个实例之后也拥有自己的color属性，但是SubType的实例都会共享一个color属性。 借用构造函数在子类型构造函数的内部调用超类型构造函数（使用call或apply）,可以在子类构造函数中向超类构造函数传递参数。 1234567891011121314function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; &#125; function SubType()&#123; SuperType.call(this,&apos;nicho&apos;); this.age = 29; &#125; var instance1 = new SubType(); instance1.colors.push(&quot;black&quot;); alert(instance1.colors); //&quot;red,blue,green,black&quot; var instance2 = new SubType(); alert(instance1.colors); //&quot;red,blue,green&quot; alert(instance1.name); //nicho 优点:解决属性共享问题缺点:方法都在超类构造函数中定义，不能实现函数复用，即超类构造函数中的每个方法都会在子类实例中重新创建一遍。函数复用即为相同的方法应该是同一个Function的实例。每个构造函数的实例调用的应该要是同一个Function实例的方法，从而达到函数复用。最好的方式是在原型中共享。 组合继承将原型链和借用构造函数的技术组合，使用原型链实现对原型属性和方法的继承，通过构造函数来实现对实例属性的继承 123456789101112131415161718192021222324function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];&#125;SuperType.prototype.syaName = function()&#123; alert(this.name);&#125;function SubType(name,age)&#123; // 调用第二次超类构造函数 SuperType.call(this,name); this.age = age;&#125;SubType.prototype = new SuperType(); //调用一次超类构造函数,使用原型链实现对原型属性和方法的继承SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;var instance1 = new SubType(&quot;nicho&quot;,29); //通过构造函数来实现对实例属性的继承instance1.colors.push(&quot;black&quot;);alert(instance1.colors); //&quot;red,blue,green,black&quot;instance1.sayName();//nichoinstance1.sayAge();//29var instance2 = new SubType(&quot;frank&quot;,27);alert(instance1.colors); //&quot;red,blue,green&quot;instance1.sayName();//frankinstance1.sayAge();//27 缺点:调用两次超类型构造函数 原型式继承(借助原型基于已有的对象创建新的对象)就是新建一个构造函数，让其prototype属性本来指向F.prototype原型对象，现在改指向person对象，由构造函数创建的新的对象proto属性指向的是构造函数prototype属性指向的对象，所以anotherPerson的proto属性指向了person对象。12345678910111213141516function object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;var person = &#123; name:&quot;Nicholas&quot;, friends:[&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]&#125;var anotherPerson = Object.create(person,&#123; name:&#123; value:&quot;Greg&quot; &#125;&#125;);alert(anotherPerson.name);//&quot;Greg&quot;es2015 新增Object.create()方法实现原型式继承，第二个参数可选 优点：不需要创建构造函数缺点:共享性属性会存在共享问题 寄生式继承(使用该继承为返回的对象添加函数)123456789function createPerson(original)&#123; var clone = object(original); clone.sayHi = function()&#123; alert(&quot;hi&quot;); &#125;; return clone; &#125; var anotherPerson = createAnother(person); anotherPerson.sayHi(); //&quot;hi&quot; 优点：不需要创建构造函数，对象可以增强功能缺点: 自定义函数不能实现复用 寄生组合式继承（通过构造函数来继承属性，通过原型链的混成形式来继承方法,避免了组合继承中调用两次超类构造函数，在子类构造函数的原型中产生不必要的属性）1234567891011121314151617181920function inheritPrototype(subType,superType)&#123; var prototype = Object.create(superType.prototype); prototype.constructor = subType; subType.prototype = prototype; &#125; function SuperType(name)&#123; this.name = name; this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;]; &#125; SuperType.prototype.syaName = function()&#123; alert(this.name); &#125; function SubType(name,age)&#123; SuperType.call(this,name); this.age = age; &#125; inheritPrototype(subType,superType); SubType.prototype.sayAge = function()&#123; alert(this.age); &#125;]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript 垃圾回收机制]]></title>
    <url>%2F2017%2F07%2F13%2FjavaScript%2Fjavascript%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[基本类型的值保存在栈内存中，引用类型保存字堆内存中。找出不再继续使用的变量，然后释放其所占内存。 标记清除当变量进入环境时（被声明）标记其“进入环境”，永远不能释放一个标记“进入环境”的变量所占的内存，因为只要执行流进入相应的环境皆有可能用到它。当变量离开环境时就将其标记为“离开环境”，（可以用变量列表标记）。垃圾回收器会在一定时间间隔内对所有变量进行标记，被标记为“离开环境“的变量即将被删除，销毁那些带标记的值并回收内存空间。 引用计数（严重问题：循环引用）追踪记录每个值被引用的次数，若被引用了则加一，若变量引用了另外一个值，则这个值得引用次数减一。当一个值得引用次数为0时，说明不再访问这个值，从而将其占用的内存回收，垃圾收集器在下次运行时就会释放引用次数为0的值所占的空间。 内存管理：解除引用 =null]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包实现循环绑定]]></title>
    <url>%2F2017%2F07%2F12%2FjavaScript%2F%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%BE%AA%E7%8E%AF%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[闭包：有权访问另一个函数作用域中的变量常见形式：在一个函数内部创建一个函数函数执行完毕后，其活动对象也不会被销毁，因为内部函数的作用域链仍然在引用这个活动对象 12345678910var name = &quot;the window&quot;; var object2 = &#123; name : &quot;My Object&quot;, getNameFunc: function()&#123; return function()&#123; return this.name; //返回 the window，此时的this指向window &#125; &#125;&#125;;alert(object2.getNameFunc()()); 函数构造器实现： 12345678910111213141516var a = []; for (var k = 0; k &lt; 100; k++) &#123; a[k] = function () &#123; alert(k) &#125;; // 可能使用了joined objects&#125;但是通过函数构造器创建的函数不会被连接。其实此时已经生成了一个闭包var a = []; for (var k = 0; k &lt; 100; k++) &#123; a[k] = Function(&apos;&apos;); // ;;一直是100个不同的函数&#125; 闭包实现。有权访问另一个函数作用域中的变量的函数. 创建闭包的常见方式, 是在一个函数内部创建另一个函数 下面这种方式其实是通过立即执行函数达到循环绑定的效果,而且是立即执行，其实未达到效果。123for (var k = 0; k &lt; 100; k++) &#123; a[k] = (function (index) &#123;alert(index)&#125;)(k); &#125; 123456789101112131415161718191. li[i].onclick = function(k)&#123; return function()&#123; alert(k); &#125;; &#125;(i); 2. li[i].onclick = (function(k)&#123; return function()&#123; alert(k); &#125;; &#125;)(i);3. (function(arg)&#123; li[arg].onclick = function() &#123; alert(arg); &#125;; &#125;)(i); &#125;;1，2，3效果相同，不要在return function中添加参数k，不然k就是事件对象]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象以及创建对象的模式]]></title>
    <url>%2F2017%2F07%2F12%2FjavaScript%2F%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[理解对象属性类型数据属性1234[[configurable]] 能否修改、删除、改为访问器属性 /false[[Enumerable]] 能否通过for-in返回属性 /flase[[Writable]] 能否修改 /false[[Value]] 数据值 /undefined 访问器属性1234[[configurable]] 能否修改、删除、改为访问器属性 /false[[Enumerable]] 能否通过for-in返回属性 /flase[[Get]] 读取属性时调用的函数[[Set]] 写入属性时调用的函数 访问器属性必须使用Object.defineProperty()来定义 123456789101112var book = &#123; _year:2014, edtion:1 &#125;Object.defineProperty(book,year,&#123; get:function()&#123; return this._year; &#125;, set:function()&#123; this.edtion = this._year-2013; &#125;&#125;) 定义多个属性使用Object.defineProperties() 123456789101112131415161718var book = &#123;&#125;Object.defineProperties(book,&#123; _year:&#123; writable:true, value:2014 &#125;, edtion:&#123; value:1 &#125;, year: &#123; get:function()&#123; return this._year; &#125;, set:function()&#123; this.edtion = this._year-2013; &#125; &#125;&#125;) 读取属性的特性Object.getOwnPropertyDescriptor(对象,属性名称),返回一个对象，这个对象的属性为访问器属性或者数据属性 创建对象工厂模式、构造函数模式、原型模式、构造函数+原型模式、动态原型模式 工厂模式优点：解决了创建多个相似对象时代码重复的问题,缺点：没有解决对象识别问题，对象的类型无法识别，每个方法在每个实例上重新创建一遍 大多数类最好使用new关键字和构造函数，可以让代码更加简单易读。而不必去查看工厂方法来知道。12345678910111213function createPerson(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125;var person1 = createPerson(&quot;Nicho&quot;,29,&apos;farmer&apos;);var person2 = createPerson(&quot;Greg&quot;,27,&apos;doctor&apos;);alert(person1 instanceof createPerson) //false 在函数中显示地创建对象 直接将属性和方法赋给新建对象 return语句返回新建对象 构造函数模式1234567891011function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = functithisn()&#123; alert(this.name); &#125;; &#125;var person1 = new Person(&quot;Nicho&quot;,29,&apos;farmer&apos;);var person2 = new Person(&quot;Greg&quot;,27,&apos;doctor&apos;);alert(person1 instanceof CreatePerson) //true 没有显示地创建对象 直接将属性和方法赋给this对象 没有return语句 优点：区别对象的类型 缺点：每个方法在每个实例上重新创建一遍,可以将sayName方法移到外面，function中只写this.sayName = sayName,但是如果函数过多则引用类型对象失去了分装性。 原型模式不必在构造函数中定义对象实例信息，而是将信息添加到原型对象中。缺点：引用类型的数据共享带来的问题最大。1234567891011//下面在原型中定义属性和方法时由于不是使用字面量定义，constructor还是指向Person。但是如果用对象字面量重写原型一定要在创建对象之前，否则实例指向的还是之前的那个原型，即使让constructor指向Person，字面量相当于创建了一个新的原型function Person()&#123;&#125;Person.prototype.name = &quot;nicholas&quot;;Person.prototype.age = 23;Person.prototype.job = &quot;engineer&quot;;Person.prototype.sayName = function()&#123;alert(this.name);&#125;;var person1 = new Person();var person2 = new Person();alert(person1 == person2) //true 通过原型对象的isPrototypeof()确定和对象实例之间是否存在原型关系， 通过使用Object.getPrototypeOf()获得对象的原型， 通过使用hasOwnProperty()监测属性在实例中还是在原型中。 Person.prototype.isPrototypeOf(person1); //true alert(Object.getPrototypeOf(person1)== Person.prototype) // true person1.hasOwnProperty(‘name’) //false; Person.prototype.hasOwnProperty(‘name’)//true; 判断属性是在原型中还是在实例中 !object.hasOwnProperty(name) &amp;&amp; (name in object) //true 在原型中，确定一个属性是否在原型中 注意原型对象重写之后，现有实例与重写的新原型没有任何关系。 组合使用构造函数模式和原型模式构造函数用于定义实例属性，原型模型用于定义方法和共享的属性，每个实例都有实力属性的副本，又共享对方法的引用 12345678910111213function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friend = [&apos;khk&apos;,&apos;kil&apos;]; &#125; Person.prototype = &#123; constructor : Person, // 重写原型之后constructor指针指向了Object，所以必须重新定义，但是如果没有定义也不会影响实例使用原型中的方法，因为实例中的_proto_属性还是指向原型对象。 sayName :function()&#123; alert(this.name); &#125; &#125; var person1 = new Person(&quot;Nicho&quot;,29,&apos;farmer&apos;); var person2 = new Person(&quot;Greg&quot;,27,&apos;doctor&apos;); 动态原型模式（解决上述构造函数和原型独立的困惑，通过检查某个应该存在的方法是否有效来决定是否需要初始化原型）123456789101112function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.friend = [&apos;khk&apos;,&apos;kil&apos;]; if(typeof this.sayName !=&apos;function&apos;)&#123; Person.prototype.sayName = function()&#123; alert(this.name); &#125;; &#125; &#125; var person1 = new Person(&quot;Nicho&quot;,29,&apos;farmer&apos;); 寄生构造函数模式(封装创建对象的代码，返回新创建的对象)123456789101112function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; var person1 = new Person(&quot;Nicho&quot;,29,&apos;farmer&apos;); alert(person1 instanceof Person) //false 与工厂模式的区别用了new,返回的对象与外部创建的对象没有区别。跟构造函数和构造函数原型没有联系，即不能使用原型中属性和方法。不能依赖instanceof操作符来确定对象类型。 稳妥构造函数模式1234567891011function Person(name,age,job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(name); //与工厂模式的区别 &#125;; return o; &#125; var person1 = Person(&quot;Nicho&quot;,29,&apos;farmer&apos;); 只有sayName函数才能访问name变量]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>创建对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单双击冲突解决]]></title>
    <url>%2F2017%2F07%2F12%2FjavaScript%2F%E5%A4%84%E7%90%86%E5%8D%95%E5%87%BB%E5%92%8C%E5%8F%8C%E5%87%BB%E5%86%B2%E7%AA%81%E7%9A%84%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[当双击时会执行两次click，第一个距离dbclick时间较长，第二个click与dbclick几乎同时发生，所以只要对click设置一个延时，这个延时时长要大于第一个click与dbclick的时间间隔，当双击时前两个click都还在任务队列里，执行到dbclick时将计时器清除，则不会执行click中延时执行的动作，达到避免双击时执行单击动作的效果 12345678910111213$(&quot;#script_list&quot;).on(&apos;dblclick&apos;,function(event)&#123; timer&amp;&amp;clearTimeout(timer); var event = event||window.event; var target = event.target||event.srcElement; $(&apos;#&apos;+target.id).parents(&apos;li&apos;).remove(); $(&quot;#script_para&quot;).attr(&#123;style:&quot;display:none&quot;&#125;); &#125;).delegate(&apos;li&apos;,&apos;click&apos;,function(event)&#123; timer&amp;&amp;clearTimeout(timer); timer = setTimeout(function()&#123; $(&quot;#script_para&quot;).attr(&#123;style:&quot;display:block&quot;&#125;); &#125;,300); &#125;)]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口、流量控制、拥塞控制]]></title>
    <url>%2F2017%2F07%2F11%2F%E7%BD%91%E7%BB%9C%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[滑动窗口 能够发送的字节序列长度，一般利用滑动窗口实现流量控制的机制，主要用于接收方告诉发送方数据不要发太快，而能传递多少数据什么时候传递则需要参照接收方传递的信息，当发送方发送了数据并收到确认消息后窗口按顺序进行滑动，此时接收方一般也是按顺序进行滑动。所谓滑动窗口协议，自己理解有两点： “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”； “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。在引入一个例子来说这个协议之前，我觉得很有必要先了解以下前提： TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子； 发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区； 发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据； 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送； 流量控制流量控制方面主要有两个要点需要掌握。一是TCP利用滑动窗口实现流量控制的机制；二是如何考虑流量控制中的传输效率。 流量控制所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的ACK中会包含自己的接收窗口的大小rwnd，并且利用大小来控制发送方的数据发送：这里面涉及到一种情况，如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知,B等待A发送数据的死锁状态。为了处理这种问题，TCP引入了持续计时器（Persistence timer），当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。 传递效率一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用Nagle算法，即： 若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来； 当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去； 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；对于后者我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。 拥塞控制拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是： 慢开始、拥塞控制 快重传、快恢复 一切的基础还是慢开始，这种方法的思路是这样的： 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口； 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文； 当收到第一个字节的数据的确认后，就发送2个字节的报文； 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级； 最后会达到一个提前预设的“慢开始门限”，比如16，即一次发送了16个分组，此时遵循下面的条件判定： cwnd &lt; ssthresh， 继续使用慢开始算法； cwnd &gt; ssthresh，停止使用慢开始算法，改用拥塞避免算法； cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法； 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长； 当出现网络拥塞，比如丢包时，将慢开始门限设为拥塞窗口大小的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）； (加法增大)上述方法的目的是在拥塞发生时循序减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。慢开始和拥塞控制算法常常作为一个整体使用。 而快重传和快恢复则是为了减少因为拥塞导致的数据包丢失带来的重传时间，因为收到三个确认之后就重传数据包而不用等待重传计时器到期，从而避免传递无用的数据到网络和等待。 快重传的机制是： 接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求； 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包之后的数据包； 此时发送方开始执行“快恢复”算法： 慢开始门限减半； cwnd设为慢开始门限的数值； 执行拥塞避免算法(加法增大)（高起点，线性增长）；收到好几个重复确认说明网络没出现拥塞，所以不执行慢开始算法而执行拥塞避免算法。 转:http://blog.chinaunix.net/uid-26275986-id-4109679.html]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>流量控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪类]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2FCSS%2BCSS3%20%E4%BC%AA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[伪类语法1selector : pseudo-class &#123;property: value&#125; CSS 类也可与伪类搭配使用1selector.class : pseudo-class &#123;property: value&#125; 锚伪类1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ first-child类12p:first-child &#123;font-weight: bold;&#125;li:first-child &#123;text-transform:uppercase;&#125; 第一个规则将作为某元素第一个子元素的所有 p 元素设置为粗体。第二个规则将作为某个元素（在 HTML 中，这肯定是 ol 或 ul 元素）第一个子元素的所有 li 元素变成大写。 属性 描述 :active 向被激活的元素添加样式。 :focus 向拥有键盘输入焦点的元素添加样式。 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 :link 向未被访问的链接添加样式。 :visited 向已被访问的链接添加样式。 :first-child 向元素的第一个子元素添加样式。 注：1234p:first-child //选择所有元素的子元素中第一个p元素p &gt; i:first-child //选择所有p元素的子元素中的第一个i元素p:first-child i // 选择所有作为第一个子元素的 &lt;p&gt; 元素中的所有 &lt;i&gt; 元素p:nth-type-of(n) //匹配是p元素的父元素的第 n 个p子元素 css3新增伪类2、CSS3新增伪类 新增伪类 作用 p:first-of-type 选择每个含有元素作为直接子元素的父元素的子元素中首个元素。 p:last-of-type 选择每个含有元素作为==直接子元素==的父元素的子元素中的最后一个个元素。 p:only-of-type 选择每个含有唯一一个元素作为直接子元素的其父元素下的唯一的那个元素。 p:only-child 选择==后代元素==中只有一个元素的元素唯一的子元素元素。 p:nth-child(n)| 先选择每个p元素的直接父元素，再选择每个父元素其下的第n个子元素，若子元素是p元素则选中。n可以是数字，表达式，奇偶 p:nth-last-child(n)|选择属于其父元素的倒数第n个子元素的每个元素。p:nth-of-type(n)| 先选择每个p元素的直接父元素，再选择每个父元素下的第n个p子元素，如果有则选中。n可以是数字，表达式，奇偶p:nth-last-of-type(n) |选择属于其父元素倒数第n个元素的每个元素。p:last-child|选择属于其父元素最后一个子元素的每个元素。p:empty|选择没有子元素的每个元素（包括文本节点）。p:target |选择当前活动的元素。:not(p)|选择非元素的每个元素。:enabled|控制表单控件的可用状态。:disabled |控制表单控件的禁用状态。:checked |单选框或复选框被选中。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪元素]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2FCSS%20%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[伪元素12selector:pseudo-element &#123;property:value;&#125;selector.class:pseudo-element &#123;property:value;&#125; ::first-line伪元素 用于向文本的首行设置特殊样式12345p:first-line &#123; color:#ff0000; font-variant:small-caps; &#125; ::first-letter伪元素 用于向文本的首字母设置特殊样式12345p:first-letter &#123; color:#ff0000; font-size:xx-large; &#125; 上述两类只能用于块元素 伪类和伪元素配合1234p.article:first-letter &#123; color: #FF0000; &#125; ::before 伪元素 在元素的内容前面插入新内容。 ::after 伪元素在元素的内容后面插入新内容。 属性 描述 ::first-letter 向文本的第一个字母添加特殊样式。 ::first-line 向文本的首行添加特殊样式。 ::before 在元素之前添加内容。 ::after 在元素之后添加内容。 ::selection(CSS3新增) 给选中文本添加效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>伪元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[原理float属性会使得普通元素脱离稳定流变成浮动元素。 存在的问题浮动的子元素显示在父容器的外部 原因在CSS规范中，浮动定位不属于正常的页面流（page flow），是独立定位的。所以，只含有浮动元素的父容器，在显示时不考虑子元素的位置，就当它们不存在一样。这就造成了显示出来，父容器好像空容器一样。 解决办法添加空元素12345&lt;div&gt; &lt;div style=&quot;float:left;width:45%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;float:right;width:45%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 原理是父容器现在必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了。这种方法比较简单，但是要在页面中增加冗余标签，违背了语义网的原则。 浮动的容器索性将父容器也改成浮动定位，这样它就可以带着子元素一起浮动了。 1234&lt;div style=&quot;float:left;&quot;&gt; &lt;div style=&quot;float:left;width:45%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;float:right;width:45%;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 缺点在于父容器变成浮动以后，会影响到后面元素的定位，而且有时候，父容器是定位死的，无法变成浮动。 浮动元素的自动clearing，触发BFC规则，不仅仅是overflow让父容器变得可以自动”清理”（clearing）子元素的浮动，从而能够识别出浮动子元素的位置，不会出现显示上的差错。要做到这点，只要为父容器加上一条”overflow: hidden”的CSS语句就行了。缺点主要有两个，一个是IE6不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题,溢出的子元素会被裁剪掉。 通过CSS语句添加子元素不用修改HTML代码有一个:after伪选择符，就可以在父容器的尾部自动创建一个子元素。 123456.clearfix:after &#123; content: &quot;\0020&quot;; display: block; height: 0; clear: both; &#125; 其中的”clearfix”是父容器的class名称，”content:”020”;”是在父容器的结尾处放一个空白字符，”height: 0;”是让这个这个空白字符不显示出来，”display: block; clear: both;”是确保这个空白字符是非浮动的独立区块。但是，:after选择符IE 6不支持，也就是说上面的这段代码在IE 6中无效，这怎么办？我们添加一条IE 6的独有命令”zoom:1;”就行了，这条命令的作用是激活父元素的”hasLayout”属性，让父元素拥有自己的布局。IE 6会读取这条命令，其他浏览器则会直接忽略它。123456789101112131415161718192021222324252627.clearfix:after &#123;content: &quot;\0020&quot;;display: block;height: 0;clear: both;&#125;.clearfix &#123;zoom: 1;&#125;通用代码/* For modern browsers */.cf:before,.cf:after &#123; content:&quot;&quot;; display:block;&#125;.cf:after &#123; clear:both;&#125;/* For IE 6/7 (trigger hasLayout) */.cf &#123; zoom:1;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容-CSS]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9-CSS%2F</url>
    <content type="text"><![CDATA[CSS常见兼容性问题总结 原文 http://www.cnblogs.com/imwtr/p/4340010.html 浏览器的兼容性问题，通常是因为不同的浏览器对同一段代码有不同的解析，造成页面显示不统一的情况。这里谈到的浏览器，主要指IE6/IE7/IE… FireFox Chrome Opera Safari 等。 但更多的兼容还是考虑IE6/IE7/FF之间的斗争先来谈谈CSS Hack我们为了让页面形成统一的效果，要针对不同的浏览器或不同版本写出对应可解析的CSS样式，所以我们就把这个针对不同浏览器/版本而写CSS的过程叫做 CSS hack. CSS hack主要有三种：IE条件注释法、CSS属性前缀法、选择器前缀法。 IE条件注释法即在正常代码之外添加判别IE浏览器或对应版本的条件注释，符合条件的浏览器或者版本号才回执行里边的代码。 12345678910&lt;!-- lt是小于 gt是大于 lte是小于等于 gte是不小于 !是不等于 --&gt;&lt;!-- [if IE]&gt; 你想要执行的代码 &lt;![endif]--&gt;&lt;!-- [if lt IE 8]&gt; 你想要执行的代码 &lt;![endif]--&gt;&lt;!-- [if ! IE 8]&gt; 你想要执行的代码 &lt;![endif]--&gt; CSS属性前缀法即是给css的属性添加前缀。比如 * 可以被IE6/IE7识别，但 只能被IE6识别，IE6-IE10都可以识别 “\9”，IE6不能识别!important FireFox不能识别* \9可以先使用“\9”标记，将IE分离出来，再用”*”分离出IE6/IE7，最后可以用“_”分离出IE6 1234567.type&#123; color: #111; /* all */ color: #222\9; /* IE */ *color: #333; /* IE6/IE7 */ _color: #444; /* IE6 */ &#125; 所以可以按着优先级就能给特定的版本捎上特定颜色一般来说，只有IE6不支持 !important 所以可以这样 1234#example&#123; width: 100px !important; /* IE7 FF */ width: 110px; /* IE6 */&#125; 因为!important 具有最高优先级，所以此种方式可以区别出来~为什么说一般呢…你看看下面这个例子，IE6貌似还认得出!important 12345h1&#123;color: #f00 !important; &#125;h1&#123;color: #000;&#125;h2&#123;color: #f00 !important; color: #000;&lt;h1&gt;test1&lt;/h1&gt;&lt;h2&gt;test2&lt;/h2&gt; 选择器前缀法，顾名思义，就是给选择器加上前缀IE6可识别 div{color:red;}IE7可识别 +div{color:red;} 其它兼容问题 最主要也是最常见的，就是浏览器对标签的默认支持不同，所以我们要统一，就要进行CSS reset . 最简单的初始化方法是 *{margin:0; padding:0;},但不推荐，而且它也并不完善。 贴一个淘宝的样式初始化~ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } IE6双边距bug:块属性标签添加了浮动float之后，若在浮动方向上也有margin值，则margin值会加倍。其实这种问题主要就是会把某些元素挤到了第二行 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; html,body,div&#123; margin: 0;padding: 0;&#125; .wrap&#123;width: 200px; height: 200px; border: 1px solid #333;&#125; .box&#123;float: left; /* display:inline */ ;margin-left: 10px; width: 80px; height: 80px; background-color: green;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt; IE6下左边的双边距 ~ IE7的没问题 ~ 解决的方式有两个： 给float元素添加display：inline 即可正常显示 就是hack处理了，对IE6进行 _margin-left:5px; 跟上述差不多，也属于IE6双边距bug:行内属性标签，为了设置宽高，我们经常就会设置成display：block; 这样一来就产生上述的问题。解决办法也是isplay：inline;但是这样一来我们就不能设置宽高了，所以呢需要再加个display:table.所以你设置display:block后，再添上display:inline和display:table 上下margin重合问题，相邻的两个div margin-left margin-right 不会重合，但相邻的margin-top margin-bottom会重合。 123456.box1&#123;width: 200px;height: 200px; border: 1px solid #333; &#125; .mt&#123;margin-top: 10px;&#125; .mb&#123;margin-bottom: 10px;&#125;&lt;div class=&quot;box1 mb&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box1 mt&quot;&gt;&lt;/div&gt; 解决办法就是不要同时采用top和bottom ,统一一些~ 有些浏览器解析img标签也有不同，img是行内的，一般都会紧接着排放，但是在有些情况下还是会突然出现个间距，解决办法是给它来个浮动float 标签属性min-height是不兼容的，所以使用的时候也要稍微改改。 1.box&#123;min-height:100px;height:auto !important; height:100px; overflow:visible;&#125; 另一方面，IE是不支持min-height这类属性的，所以有些时候也可以考虑使用CSS表达式 12345#container&#123; min-width:600px; width: expression(document.body.clientWidth &lt; 600? &quot;600px&quot;:&quot;auto&quot;);&#125; 很多时候可能会纳闷超链接访问过后样式就混乱了，hover样式不出现了。其实主要是其CSS属性的排序问题。一般来说，最好按照这个顺序：L-V-H-A 简单的记法是 love hate 1a:link&#123;&#125; a:visited&#123;&#125; a:hover&#123;&#125; a:active&#123;&#125; chrome下默认会将小于12px的文本强制按照12px来解析。解决办法是给其添加属性： 1-webkit-text-size-adjust: none; png24位的图片在IE6下面会出现背景，所以最好还是使用png8格式的 因为存在两种盒子模式：IE盒子模式和W3C标准模式，所以对象的实际宽度也要注意。 IE/Opera：对象的实际宽度 = (margin-left) + width + (margin-right)Firefox/Mozilla：对象的实际宽度= (margin-left) + (border-left-width) + (padding- left) + width + (padding-right) +(border-right-width) + (margin-right) 鼠标的手势也有问题：FireFox的cursor属性不支持hand，但是支持pointer，IE两个都支持；所以为了兼容都用pointer 消除ul、ol等列表的缩进时，样式应写成: 1list-style:none;margin:0px;padding:0px; 其中margin属性对IE有效，padding属性对FireFox有效 CSS控制透明度问题：一般就直接 opacity: 0.6 ; IE就 filter: alpha(opacity=60)但在IE6下又有问题，所以又得弄成 filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60); 有些时候图片下方会出现一条间隙，通常会出现在FF和IE6下面比如 1&lt;div&gt;&lt;img src=&quot;1.jpg&quot;/&gt;&lt;/div&gt; 一般给img添加vertical-align属性即可，比如top middle 1img&#123;verticle-align:center;&#125; IE6下div高度无法小于10px,比如定义一条高2px的线条，FF和IE7都正常但IE6就是10px解决的办法有两种：添加overflow属性或设置fontsize大小为高度大小 如： 123&lt;div style=&quot;height:2px;overflow:hidden;background:#000000;width:778px;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;height:2px;font-size:2px;background:#000000;width:778px;&quot;&gt;&amp;nbps;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核及CSS适配]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E4%BB%A5%E5%8F%8Acss%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[各浏览器内核 Webkit内核：使用此引擎内核的浏览器有：Safari(包括移动版和桌面版)、Chrome。其私有属性的前缀是-webkit-。 Gecko内核：使用此引擎内核的浏览器有Mozilla，常指的是Firefox浏览器。其私有属性的前缀是-moz-。 Presto内核：使用此引擎内核的浏览器是指Opera。其私有属性的前缀是-o-。 KHTML内核：使用此引擎内核的浏览器是指Konqueror。其私有属性的前缀是-khtml-。 Trident内核：使用此引擎内核的浏览器是IE浏览器。其私有属性的前缀是-ms-。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浏览器内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流式、响应布局]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E6%B5%81%E5%A4%B1%E5%B8%83%E5%B1%80%20%20%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[流式布局流式布局就是每一排固定排列子项数，当项目超过预定数则进行换行，而且可以自适应宽度12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-wrap: wrap; align-content: flex-start; &#125; .child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应布局响应布局也是为了根据空间大小动态给子项分配空间12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; .Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 0 0 0%;&#125;.Grid-cell.u-full &#123; flex: 0 0 100%;&#125;.Grid-cell.u-1of2 &#123; flex: 0 0 50%;&#125;.Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%;&#125;.Grid-cell.u-1of4 &#123; flex: 2 0 25%;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot; style=&quot;background-color:red&quot;&gt;25%&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color:red&quot;&gt;100%&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of2&quot; style=&quot;background-color:red&quot;&gt;50%&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平居中布局]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[margin:0 auto;（最常用的居中布局方式,元素宽度已知（块级元素有宽度，内联元素有内容）,未浮动，一定是用在元素本身不是父元素。父元素如果是块级元素则不用设置width默认占据一行。父元素如果是内联元素则需要display:inline-block,再设置宽度。如果是多个内联元素或者多个块级元素，则需要都放在一个块级元素里再使用此方法。因为设置完了display: inline-block 之后margin：0 auto无效了，或者直接使用第二种方法。 text-align和inline-block的结合（设置父元素的text-align为center）。这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。多个块级元素水平排列居中布局时更适合选用这种方法。 position绝对定位来实现居中布局。适用于块级元素不给出宽高的情况下(需要借助transtrom的tanslateX方法)，当又需要对多个child进行居中时需要在child外层再加一个div并对其进行定位。 #parent{ position: relative; } #child{ position: absolute; left: 50%; top: 0; -ms-transform: translate(-50%); -moz-transform: translate(-50%); -o-transform: translate(-50%,); transform: translate(-50%); background-color: #ccc; } 利用flex弹性布局的一个属性子元素是否有宽度不重要body{ display: flex; justify-content:center; } 浮动实现水平居中的方法12345678910111213141516171819202122232425.child&#123; float: left; position: relative; right: 50%; &#125; #part&#123; float:left; width:100%; overflow: hidden; position: relative; &#125; #part2&#123; clear: left; float: left; position: relative; left:50%; &#125; &lt;div id=&quot;part&quot;&gt; &lt;div id=&quot;part2&quot;&gt; &lt;div class=&quot;child&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;thr&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;four&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS3的fit-content实现水平居中方法居中一个浮动元素 123456789.child&#123; float: left; &#125; #part2&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; 以下例子中除了第一种方式需要给宽度，其它方式都能不给宽度。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; .first-way&#123; width:100px; height: 100px; background-color: red; margin: 0 auto; &#125; .second-way&#123; width:100%; text-align: center; overflow: hidden;//实际是没有的 &#125; .second-child&#123; display: inline-block; width:100px; height:100px; background-color: red; &#125; .third-way&#123; position: absolute; left:50%; top:0%; /*默认应该是0%*/ transform:translateX(-50%); /*向左移动元素宽度的一半长度*/ width:300px; height:100px; border: 1px solid green; &#125; .fourth-way&#123; display: flex; justify-content:center; &#125; .fourth-way &gt; div&#123; width:100px; height:100px; background-color: red; &#125; .five-way&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; .five-way &gt; div&#123; float:left; width:100px; height:100px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first-way&quot;&gt; 第一种方式 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;second-way&quot;&gt; &lt;div class=&quot;second-child&quot;&gt;第二种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;third-way&quot;&gt; 第三种方式 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;fourth-way&quot;&gt; &lt;div&gt;第四种&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;/br&gt; &lt;div class=&quot;five-way&quot;&gt; &lt;div&gt; 第五种 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分布局浅析]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[水平居中 方法一：margin:0 auto; （最常用的居中布局方式,元素宽度已知（块级元素有宽度，内联元素有内容）,未浮动，一定是用在元素本身不是父元素。父元素如果是块级元素则不用设置width默认占据一行。父元素如果是内联元素则需要display:inline-block,再设置宽度。如果是多个内联元素或者多个块级元素，则需要都放在一个块级元素里再使用此方法。因为设置完了display: inline-block 之后margin：0 auto无效了，或者直接使用第二种方法。 text-align和inline-block的结合（设置父元素的text-align为center）。这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。多个块级元素水平排列居中布局时更适合选用这种方法。 position绝对定位来实现。适用于块级元素不给出宽高的情况下==(需要借助transtrom的tanslateX方法)，当又需要对多个child进行居中时需要在child外层再加一个div并对其进行定位。 12345678910111213 #parent&#123; position: relative;&#125; #child&#123; position: absolute; left: 50%; top: 0; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); background-color: #ccc;&#125; 利用flex弹性布局的一个属性子元素是否有宽度不重要 1234body&#123; display: flex; justify-content:center; &#125; 浮动实现水平居中的方法 12345678910111213141516171819202122232425.child&#123; float: left; position: relative; right: 50%; &#125; #part&#123; float:left; width:100%; overflow: hidden; position: relative; &#125; #part2&#123; clear: left; float: left; position: relative; left:50%; &#125; &lt;div id=&quot;part&quot;&gt; &lt;div id=&quot;part2&quot;&gt; &lt;div class=&quot;child&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;thr&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;four&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS3的fit-content实现水平居中方法居中一个浮动元素 123456789.child&#123; float: left; &#125; #part2&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; 水平垂直居中 文字垂直居中： height:50px; line-height:50px; overflow:hidden; 1234567891011121314151617181920211 子元素 div 绝对定位 2 父元素需要被定位 3 子元素 top、bottom、left、right 四个位置值均为 0 4 子元素 margin: auto; #parent&#123; width: 100%; height:100%; position: fixed; &#125; #child&#123; width: 200px; height: 100px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; background-color: #ccc; &#125; 利用position的绝对定位及负外边框距来实现。 123456789101112131415#parent&#123; position: fixed; width: 100%; height: 100%; &#125; #child&#123; position: absolute; left: 50%; top: 50%; width: 400px; height: 200px; margin-top: -height/2px; margin-left: -width/2px; background-color: #ccc; &#125; 对于未给出宽高的元素，又需要运用transform并且运用绝对定位和正外边距来实现。 123456789#parent&#123; position: relative; &#125; #child&#123; position: absolute; left: 50%; top: 50%; transform:translate(-50%,-50%); &#125; 运用flex布局，要给父元素一个高度，不然无法垂直居中 12345678#parent&#123; display: flex; justify-content:center; height:100%; &#125; #child&#123; align-self:center; &#125; 左边固定，右边自适应的两列布局方式一：float+margin 需要清除浮动 1234567#left&#123; float: left; width: 100px; &#125; #right&#123; margin-left: 120px; &#125; 方式二：float+overfloww 不用清除浮动 123456#left&#123; float: left; width: 100px; margin-right: 20px; &#125; #right&#123; overflow: hidden; &#125; 方式三：float+margin+position 123456789101112131415#parent&#123; position: relative; &#125; #left&#123; float: left; width: 100px; background-color: #ccc; &#125; #right&#123; position: absolute; top: 0; left: 120px; background-color:pink; &#125; 方式四：flex 12345678#parent&#123; display: flex; &#125; #left&#123; width: 100px; margin-right: 20px; &#125; #right&#123; flex: 1; &#125; 右边固定，左边自适应的两列布局 –与3类似两边固定中间自适应方式一：使用float 1234.left&#123; float: left; width: 200px; height: 200px; &#125; .right&#123; float: right; width: 100px; height: 100px; &#125; .middle&#123; margin:0 120px 0 220px; &#125;** 关键是html中中间的div放在最后，不然right div会距离上部有空隙 方式二：position绝对定位 1234.parent&#123; position: relative; &#125; .left&#123; position: absolute; width: 200px; height: 200px; top: 0; left: 0; &#125; .right&#123; position: absolute; top: 0; right: 0; width: 100px; height: 100px; &#125; .middle&#123; margin:0 120px 0 220px; &#125; 方式三：flex 1234.parent&#123; display: flex; &#125; .left&#123; width: 200px; height: 200px; &#125; .right&#123; width: 100px; height: 100px; &#125; .middle&#123; flex: 1; margin:0 20px; &#125; 方式四：margin负值法123456789101112131415161718192021222324252627#main&#123; width: 100%; float: left;&#125;#main #body&#123; margin: 0 120px; background-color: #ffe6b8;&#125;#left,#right&#123; width:100px; height: 100%; float: left; background-color: #a0b3d6;&#125; #left&#123; margin-left: -100%; &#125;#right&#123; margin-left: -100px; &#125;&lt;div class=&quot;fourth&quot;&gt;&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt;&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #parent&#123; width:100px; height:100px; background-color: #eee; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其它布局方式]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E5%85%B6%E5%AE%83%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[网格布局基本网格布局-平分布局空间HTML代码如下。 12345&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;/div&gt; CSS代码如下。 1234567.Grid &#123; display: flex; &#125; .Grid-cell &#123; flex: 1; &#125; 百分比布局某个网格宽度固定百分比，其余网格平均分配剩余空间 HTML代码如下。 123456789101112131415161718192021222324252627282930&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of2&quot;&gt;...&lt;/div&gt; &lt;/div&gt; .Grid &#123; display: flex; &#125; .Grid-cell &#123; flex: 1; = flex:1 1 0% &#125; .Grid-cell.u-full &#123; flex: 0 0 100%; &#125; .Grid-cell.u-1of2 &#123; flex: 0 0 50%; &#125; .Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%; &#125; .Grid-cell.u-1of4 &#123; flex: 2 0 25%; &#125; 计算方法：先算占比50%+25% = 75%flex-basis都是按总宽度来算，f2占总宽度50%，f4占总宽度25%，剩余25%分成3份，Grid-cell占三分之一，f4占三分之二。 圣杯布局 页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。HTML代码如下： 123456789&lt;body class=&quot;HolyGrail&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt; CSS代码如下： 1234567891011121314151617181920212223242526272829.HolyGrail &#123; display: flex; min-height: 100vh;//浏览器视口的高度 flex-direction: column; &#125; header, footer &#123; flex: 1; &#125; .HolyGrail-body &#123; display: flex; flex: 1; &#125; .HolyGrail-content &#123; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ flex: 0 0 12em; &#125; .HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1; &#125; 悬挂式布局主栏的左侧或右侧，需要添加一个图片栏HTML代码如下。 1234&lt;div class=&quot;Media&quot;&gt; &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt; &lt;/div&gt; CSS代码如下。 123456789101112.Media &#123; display: flex; align-items: flex-start; &#125; .Media-figure &#123; margin-right: 1em; &#125; .Media-body &#123; flex: 1; &#125; 固定的底栏HTML代码如下。 12345&lt;body class=&quot;Site&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class=&quot;Site-content&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt; CSS代码如下。 123456789.Site &#123; display: flex; min-height:100vh;//视口默认被均分为100vh flex-direction: column; &#125; .Site-content &#123; flex: 1; &#125; 流式布局每行项目数固定，会自动分行 123456789101112131415.parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-wrap: wrap; align-content: flex-start; &#125;.child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局(双飞翼布局)]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在三栏布局的所有方法中，margin负值法三栏相互关联，可谓真正意义上的自适应，布局不易受内部影响。缺点在于：代码相对复杂。原理:首先设置main的width为100%,然后三者float:left,则按html顺序是main、left、right，此时由于main独占一行从而使得left和right换行显示。再设置left的margin-left:-100%,使得left向左平移了100%width到达最左边并且左外边框与浏览器窗口重合，再令right的margin-left: -100px，向左平移100px，最后设置body的margin: 0 120px,使得三者分开。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;html,body&#123; height: 100%; margin: 0 ;&#125; /* float 关键是要把主体div放在最后，左右两栏div顺序任意。 代码足够简洁与高效 不足在于clear:both属性不能加在中间div上 */ .first div&#123; background-color: red; &#125; .first &gt; .left&#123; float: left; width: 100px; height: 100px; &#125; .first &gt; .right&#123; float: right; width: 100px; height: 100px; &#125; .first &gt; .middle&#123; margin:0 120px; height: 100px; &#125; /*position绝对定位 理解容易，上手简单，受内部元素影响而破坏布局的概率低 */ .second div&#123; background-color: green; &#125; .second &gt; .left,.second &gt; .right&#123; position: absolute; width:100px; height: 100px; top:120; /*默认应该为0*/ &#125; .second &gt; .left&#123;left:0;&#125; .second &gt; .right&#123;right: 0;&#125; .second &gt; .middle&#123;height: 100px;margin :0 120px;&#125; /*display:flex*/ .third&#123; display: flex; &#125; .third div&#123; background-color: #eee; &#125; .third &gt; .left,.third &gt; .right&#123; width:100px; height: 100px; &#125; .third &gt; .middle&#123; flex:1; margin: 0 10px; &#125; /* */ #main&#123; width: 100%; float: left; &#125; #main #body&#123; margin: 0 120px; background-color: black; &#125; #left,#right&#123; width:100px; height: 100%; float: left; background-color: black; &#125; #left&#123; margin-left: -100%; &#125; #right&#123; margin-left: -100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;div3&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; //写到最后 &lt;/div&gt;&lt;/br&gt; &lt;div class=&quot;second&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;div3&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; //写到最后 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;third&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; &lt;div id=&quot;div3&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;fourth&quot;&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; //写到前面 &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS3的新特性整理animation IE10+animation的六大属性 animation-name规定需要绑定选择器的keyframe名称 animation-duration规定完成动画所花费的时间 s ms ，object.style.animationDuration=”3s” animation-timing-function动画的速度曲线，默认值ease，object.style.animationTimingFunction=”linear”，语法 animation-timing-function:value animation-timing-function使用名为三次Cubic Bezier贝塞尔曲线函数的数学函数，来生成速度曲线 可以使用自己的值也可 以预定义的值 值:linear从始到末以相同的速度 ease 默认 从低速 加快在结束前变慢 ease-in动画低速开始 ease-out动画低速结束 ease-in-out动画从低速开始和结束 cubic-bezier(n,n,n,n)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值 animation-deplay动画开始之前的延迟 animation-delay: time; JavaScript 语法：object.style.animationDelay=&quot;2s&quot; animation-delay 值以秒或毫秒计。 允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画 animation-iteration-count动画播放的次数 IE10 animation-iteration-count: n|infinite JavaScript 语法： object.style.animationIterationCount=3 animation-direction是否应该轮流反向播放动画 animation-direction 值是 &quot;alternate&quot;，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等 ）向后播放 animation-direction: normal|alternate; JavaScript 语法： object.style.animationDirection=&quot;alternate&quot; 默认值 none 0 ease 0 1 normal javascript的语法 object.style.animation=&quot;mymove 5s infinite&quot; 123456789101112131415161718192021div&#123;width:100px;height:100px;background:red;position:relative;animation:mymove 5s infinite;-webkit-animation:mymove 5s infinite; /*Safari and Chrome*/&#125;@keyframes mymove&#123;from &#123;left:0px;&#125;to &#123;left:200px;&#125;&#125;@-webkit-keyframes mymove /*Safari and Chrome*/&#123;from &#123;left:0px;&#125;to &#123;left:200px;&#125;&#125; Transition 过渡的四大属性 IE10+transition-propertytransiont-property属性规定过渡css属性的名称transition-property: none|all|propertyCSS 属性名称列表，列表以逗号分隔;JavaScript 语法： object.style.transitionProperty=”width,height” transition-duration完成过渡效果需要多少秒或毫秒transition-duration: time;JavaScript 语法： object.style.transitionDuration=”5s” transition-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);JavaScript 语法： object.style.transitionTimingFunction=”linear” transition-delayJavaScript 语法： object.style.transitionDelay=”2s”transition-delay: time; 默认值 all 0 ease 0transition:property duration timing-function delayjavascript语法：object.style.transition=”width 2s” 123456789101112131415div&#123;width:100px;height:100px;background:blue;transition:width 2s;-moz-transition:width 2s; /* Firefox 4 */-webkit-transition:width 2s; /* Safari and Chrome */-o-transition:width 2s; /* Opera */&#125;div:hover&#123;width:300px;&#125; transform IE10transform 允许我们对元素进行旋转、缩放、移动、或倾斜默认nonejavascript的语法 object.style.transform=”rotate(7deg)”transform: none|transform-functions; none 不进行转换matrix(n,n,n,n,n,n)使用六个值的矩阵matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)使用 16 个值的 4x4 矩阵translate(x,y)2D 转换translate3d(x,y,z)3D 转换translateX(x)只是用 X 轴的值translateY(y)只是用Y轴的值translateZ(z)只是用Z轴的值scale(x,y)2D缩放scale3d(x,y,z)3D缩放scaleX(x),scaleY(y),scaleZ(z)rotate(angle) 2D 旋转，在参数中规定角度rotate3d(x,y,z,angle)3D 旋转rotateX(angle),rotateY(angle),rotateZ(angle)skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换skewX(angle) skewY(angle) perspective(n) 新增的css3的选择器 1234567891011121314151 E:nth-last-child(n) 2 E:nth-of-type(n) 3 E:nth-last-of-type(n) 4 E:last-child 5 E:first-of-type 6 E:only-child 7 E:only-of-type 8 E:empty 9 E:checked 10 E:enabled 11 E:disabled 12 E::selection 13 E:not(s) 14 E::not(.s) 15 body: nth-child(even), nth-child(odd)/*：此处他们分别代表了表格（tbody）下面的偶数行和奇数行（tr）*/等等...... @Font-face 特性Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体 Font-face 客户端字体案例 arial courier verdana Font-face 服务端字体案例 12345678910111 @font-face &#123; 2 font-family: BorderWeb; 3 src:url(BORDERW0.eot); 4 &#125; 5 @font-face &#123; 6 font-family: Runic; 7 src:url(RUNICMT0.eot); 8 &#125; 9 10 .border &#123; FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: &quot;BorderWeb&quot; &#125; 11 .event &#123; FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: &quot;Runic&quot; &#125; Word-wrap设置或检索当当前行超过指定容器的边界时是否断开转行，文字此时已被打散Text-overflow它与 word-wrap 是协同工作word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow则设置或检索当当前行超过指定容器的边界时如何显示 1 .clip{text-overflow:clip; overflow:hidden; white-space:nowrap;2 width:200px;background:#ccc;}3 .ellipsis{text-overflow:ellipsis; overflow:hidden; white-space:nowrap;4 width:200px; background:#ccc;} 1 不显示省略标记，而是简单的裁切条23 当对象内文本溢出时显示省略标记 文本渲染 1 div {2 -webkit-text-fill-color: black;3 -webkit-text-stroke-color: red;4 -webkit-text-stroke-width: 2.75px;5 } Text-fill-color: 文字内部填充颜色Text-stroke-color: 文字边界填充颜色Text-stroke-width: 文字边界宽度 gradient 渐变效果线性渐变 linear左上（0% 0%）到右上(0% 100%) background-image:-webkit-gradient(linear,0% 0%,100% 0%,form(red),to(balck)) background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),color-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E)); 径向渐变radial从一个圆到一个圆的渐变background:-weblit-gradient(radial,50 50,50,50 50,0,form(black),color-stop(0.5,red),to(blue)); css3的阴影shadow和反射reflect background-clip:border-box;背景从border开始显示；background-clip：padding-boxbackground-clip：content-boxbackground-clip:no-clip:no-clicp默认属性等同于border-box background-origin 用于确定背景的位置 通常与background-positon联合使用 background-size来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身 background-size: contain; 缩小图片以适合元素（维持像素长宽比）background-size: cover; 扩展元素以填补元素（维持像素长宽比）background-size: 100px 100px; 缩小图片至指定的大小 .background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元 素没有分成多个盒子，依然是一个整体一 样）background-break: bounding-box; 把盒之间的距离计算在内；background-break: each-box; 为每个盒子单独重绘背景 counter()=[counter(name) | counters(name,list-style-type)]{1,} counter-reset IE8 counter-reset 属性设置某个选择器出现次数的计数器的值。默认为 0。利用这个属性，计数器可以设置或重置为任何值，可以是正值或负值。如果没有提供 number，则默认为 0。注释：如果使用 “display: none”，则无法重置计数器。如果使用 “visibility: hidden”，则可以重置计数器 JavaScript 语法： object.style.counterReset=”subsection” counter-reset的值none id number inherit attr()=attr(attr-name)插入元素的属性值 IE8 calc() =calc(四则运算) 动态计算长度值 IE9需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；calc()函数支持 “+”, “-“, “*”, “/“ 运算；calc()函数使用标准的数学运算优先级规则； initial属于css-wide关键字，这表示所有的属性都可以接受该值 IE11 unset 擦除属性声明 颜色值color color的颜色名称，HEX，RGB，RGBA，HSL，HSLA，transparent,currentColor currentColor resolution分辨率值不允许有负值频率单位包括有： dpi, dpcm, dppx 角度值 angle角度值的正常范围应在[0-360deg]内，例如：-10deg与350deg是等价的角度单位包括有： deg, grad一个圆共400梯度, rad 一个圆共2π弧度, turn90deg = 100grad = 0.25turn ≈ 1.570796326794897rad 长度值与单位ch 数字“0”的宽度 ie9 rem 相对长度单位。相对于根元素(即html元素)font-size计算值的倍数 vw 相对于视口的宽度。视口被均分为100单位的vw ie9 vh 相对于视口的高度。视口被均分为100单位的vh vmax 相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax vmin 相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin q 1/4毫米（quarter-millimeters）。绝对长度单位。 1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px @import@media@font-face@keyframes@supports CSS3 的盒子模型盒子模型为开发者提供了一种非常灵活的布局方式，但是支持这一特性的浏览器并不多，目前只有 webkit 内核的新版本 safari 和 chrome 以及 gecko 内核的新版本 firefox]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中布局]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[水平垂直居中布局方法中的重点就是position、flex、margin,以下就是demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body,html&#123; height: 100%; &#125; .first-way&#123; height: 100%; display: flex; justify-content:center; &#125; .first-way &gt; div&#123; align-self:center; width:100px; height:100px; background-color: red; &#125; /* .second-way&#123; width:100%; height: 100%; position: relative; &#125; */ .second-way &#123; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:150px; height: 150px; border: 1px solid green; &#125; .third-way &gt; div&#123; position: absolute; top:0; left: 0; right: 0; bottom: 0; margin: auto; width: 200px; height: 200px; border: 1px solid black; &#125; .fourth-way&#123; position: absolute; left:50%; top:50%; width:250px; height: 250px; margin-top:-125px; margin-left: -125px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first-way&quot;&gt; &lt;div&gt;第一种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-way&quot;&gt; &lt;div &gt;第二种方式&lt;/div&gt; &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;third-way&quot;&gt; &lt;div&gt;第三种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;fourth-way&quot;&gt; &lt;div&gt;第四种&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 缓存机制]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FHTML5%20Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTML5 之离线应用Manifest 在服务器上添加MIME TYPE支，让服务器能够识别manifest后缀的文件AddType text/cache-manifest manifest 创建一个后缀名为.manifest的文件，把需要缓存的文件按格式写在里面，并用注释行标注版本 CACHE MANIFEST # 直接缓存的文件 CACHE: Path/to/cache.js # version：2012-03-20 给 标签加 manifest 属性，并引用manifest文件 离线应用访问及更新流程： 第一次访问离线应用的入口页HTML（引用了manifest文件），正常发送请求，获取manifest文件并在本地缓存，陆续拉取manifest中的需要缓存的文件再次访问时，无论在线离线与否，都会直接从缓存中获取入口页HTML和其他缓存的文件进行展示。如果此时在线，浏览器会发送请求到服务器请求manifest文件，并与第一次访问的副本进行比对，如果发现版本不一致，会陆续发送请求重新拉取入口文件HTML和需要缓存的文件并更新本地缓存副本。之后的访问重复第2步的行为 离线机制的缓存用途： 从Manifest的机制来看，即使我们不是为了创建离线应用，也同样可以使用这种机制用于缓存文件，可以说是给Web缓存提供多一种可以选择的途径。 存在的问题：缓存文件更新控制不灵活就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。 HTML5 之本地存储localstorageHTML5给我们提供本地存储localstorage特性，严格来讲，其实已经不算传统Web缓存的范畴。因为它存储的地方是跟Web缓存分开的，是浏览器重新开辟的一个地方。 localstorage的作用本地存储localstorage的作用主要使Web页面能够通过浏览器提供的set/get接口，存储一些自定义的信息到本地硬盘，并且在单次访问或以后的访问过程中随时获取或修改。 Localstorage的使用Localstorage提供了几个非常易用的Api，setItem/getItem/removeItem/clear Localstorage的缓存用途Localstorage设计的本意可能是用来存储一些用户操作的个性化设置的文本类型的信息和数据，当我们其实也可能拿来当Web缓存区使用，比如我们可以将Base64格式编码的图片信息，存在localstorage中，再次访问时，直接本地获取后，使用Css3的Data:image的方式直接展现出来。 存在的问题：大小限制按照目前标准，目前浏览器只给每个独立的域名提供5m的存储空间，当存储超过5m，浏览器就会弹出警告框。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存作用及类型]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FWeb%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Web缓存的作用1.减少带宽消耗 2.降低服务器压力 3.减少网络时延 Web缓存的类型数据库数据缓存将查询的数据结果直接存储到内存中，下次查询时直接从内存中读取，提高响应效率。 服务器端缓存 代理服务器共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效。 CDN缓存。浏览器先向CDN边缘节点发起Web请求,若CDN节点中缓存的数据没有过期，则直接将数据返回到客户端，否则向源节点发送请求，获得数据之后更新CDN节点缓存的数据并返回到客户端 浏览器端缓存浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现 Web应用层缓存应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Web缓存类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web浏览器缓存机制]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FWeb%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、浏览器的缓存规则 从新鲜度和检验值两个维度来规定浏览器是否直接使用缓存中的副本还是重新获取资源。 新鲜度(过期机制，优先级高) Expires(过期日期) Cache-Control(max-age(多少秒数后过期) no-chahe(忽略缓存的副本而向服务器发送请求) no-store(强制缓存不要保留副本并直接向服务器发送请求) 不会发送请求到服务器去验证资源的新旧程度，满足任一即可： 含有完整的过期时间控制头信息（HTTP协议报文），并且仍在有效期内 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度。 校验值(验证机制) Last-Modified（文件最后修改时间） ETag(文件标识，只要文件改变标识就会变化)(优先级高))第二次请求时会将If-Modified-Since或者If-None-Match发送给服务器验证资源的新旧程度 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需要重新获取资源内容。 二、浏览器缓存的控制使用HTML Meta标签告诉页面忽略缓存副本，每次都向服务器请求资源，缓存代理器不支持，部分浏览器不支持 使用缓存相关的HTTP消息报头1.Cahce-Control与ExpiresCache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。 2.Last-Modified/ETag与Cache-control/Expries 配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器； Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。 3.Last-Modified与ETag服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 三、哪些请求不能被缓存无法被浏览器缓存的请求： HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 经过HTTPS安全加密的请求 POST请求无法被缓存 HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定位]]></title>
    <url>%2F2017%2F07%2F07%2FCSS%2FCSS%20%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[相对定位 position:relative设置为相对定位的元素框会相对于正常位置偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。相对于的是元素之前的外边距(margin)左上角进行定位在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 position:absolute设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素(最近的已定位的非static祖先元素)，或者是初始包含块(body或 HTML 元素)，如果这个元素没有设置left、top等定位值，则这个元素会像一个普通inline-block元素一样随着父元素移动，但其实已经脱离了文档流，只要设置了定位值就会展现出脱离文档流的效果。其一，无定位值的absolute元素可以使用margin定位；其二，无定位值的absolute元素是个没有实际宽度的浮动元素。其三，absolute相对父元素的内边距(padding)左上角进行定位 绝对定位 position:fixed生成绝对定位元素，该元素相对于浏览器窗口进行定位，元素的位置 通过left、top、right、bottom属性进行规定 浮动1float:&#123;left、right&#125;//浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 清除浮动1clear：&#123;left right both none&#125;//规定元素的哪一侧不允许其他浮动元素 clip、z-index只能在定位元素上有效left、top、right、bottom这4个属性值，它们都是配合position属性使用的，只有当position属性设置为 absolute、fixed、relative才有效，否则没有任何意义属性 | 描述—|—position| 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。top| 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。right| 定义了定位元素右外边距边界与其包含块右边界之间的偏移。bottom| 定义了定位元素下外边距边界与其包含块下边界之间的偏移。left| 定义了定位元素左外边距边界与其包含块左边界之间的偏移。overflow| 设置当元素的内容溢出其区域时发生的事情,属性值有visible、hidden、scroll（剪掉但是会有滚动条以便查看）、auto。clip| 设置元素的形状。元素被剪入这个形状之中，然后显示出来，裁剪绝对定位元素。vertical-align| 设置元素的垂直对齐方式，适用于内联及 table-cell 元素。z-index| 设置元素的堆叠顺序,z-index属性只能应用于使用了绝对定位的元素。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS定位方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种距离]]></title>
    <url>%2F2017%2F07%2F06%2FCSS%2FoffsetLeft%2CLeft%2CclientLeft%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[clientWidth：可见窗口clientWidth = width+padding-滚动条clientHeight = height+padding-滚动条 offsetWidth:元素自身offsetWidth = width+padding+borderoffsetHeight = height+padding+border scrollWidth:元素自身scrollWidth = width+padding+border+marginscrollHeight = height+padding+border+margin http://blog.csdn.net/xxb2008/article/details/9109329]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>offsetLeft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3圆角]]></title>
    <url>%2F2017%2F07%2F05%2FCSS%2FCSS3%E5%9C%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[border-radius属性每个圆角存在”水平半径”（horizontal radius）和”垂直半径”（vertical radius）。border-radius可以同时设置1到4个值。如果设置1个值，表示4个圆角都使用这个值。如果设置两个值，表示左上角和右下角使用第一个值，右上角和左下角使用第二个值。如果设置三个值，表示左上角使用第一个值，右上角和左下角使用第二个值，右下角使用第三个值。如果设置四个值，则依次对应左上角、右上角、右下角、左下角（顺时针顺序）border-radius: 15px 5px;border-radius还可以用斜杠设置第二组值。这时，第一组值表示水平半径，第二组值表示垂直半径。第二组值也可以同时设置1到4个值，应用规则与第一组值相同。 1border-radius: 15px 5px / 3px;// 水平半径：15px 5px 15px 5px;垂直半径: 3px 3px 3px 3px 单个圆角的设置除了同时设置四个圆角以外，还可以单独对每个角进行设置。对应四个角，CSS3提供四个单独的属性：1234border-top-left-radiusborder-top-right-radiusborder-bottom-right-radiusborder-bottom-left-radius 这四个属性都可以同时设置1到2个值。如果设置1个值，表示水平半径与垂直半径相等。如果设置2个值，第一个值表示水平半径，第二个值表示垂直半径 浏览器支持IE 9+、Opera 10.5、Safari 5、Chrome 4和Firefox 4，都支持上述的border-radius属性。早期版本的Safari和Chrome，支持-webkit-border-radius属性，早期版本的Firefox支持-moz-border-radius属性。 目前来看，为了保证兼容性，只需同时设置-moz-border-radius和border-radius即可。12-moz-border-radius: 15px;border-radius: 15px; （注意：border-radius必须放在最后声明，否则可能会失效。） 另外，早期版本Firefox的单个圆角的语句，与标准语法略有不同。1234-moz-border-radius-topleft（标准语法：border-top-left-radius）-moz-border-radius-topright（标准语法：border-top-right-radius）-moz-border-radius-bottomleft（标准语法：border-bottom-left-radius）-moz-border-radius-bottomright（标准语法：border-bottom-right-radius） 摘自: 阮一峰大师的博客]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2017%2F07%2F04%2FCSS%2F%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B-flex%E5%B8%83%E5%B1%80%EF%BC%88%E6%89%BE%E6%97%B6%E9%97%B4%E5%8F%8D%E5%90%91%E5%AE%9E%E7%8E%B0%E7%AD%9B%E5%AD%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Flex布局flex布局一个容器指定为flex布局： 123.box&#123; display: flex; &#125; 行内元素也可以使用Flex布局。 12345678910.box&#123; display: inline-flex;&#125;.box&#123; display: -webkit-flex; /* Safari chrome*/ display: -moz-flex; /*firefox*/ display: -ms-flex; /*ie*/ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用flex布局的元素称为容器，其所有子元素称为容器成员，即为flex项目，容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end。交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 flex-direction1234567.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125;row(默认值)：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap123.box&#123; flex-wrap: nowrap(不换行) | wrap(换行) | wrap-reverse(换行，第一行在下方);&#125; flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 12345678 .box &#123; justify-content: flex-start | flex-end | center | space-between | space-around; &#125;flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items定义项目在交叉轴上如何对齐。12345678 .box &#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125;flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123456789 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125;flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴 项目的属性order定义项目的排列顺序。数值越小，排列越靠前，默认为0。1234.item &#123; order: &lt;integer&gt;;&#125; flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inline、block、inline-block之间的区别]]></title>
    <url>%2F2017%2F07%2F03%2FCSS%2Finline%E3%80%81block%E3%80%81inline-block%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[inline inline元素不会独占一行，多个相邻的行内元素在一行中排列，除非一行排列不下才会换一行，其高度随元素的内容而变化。 设置width、height属性无效 元素的margin、padding在水平方向会产生边距效果，但竖直方向不会。 block block元素独占一行，默认填满父元素宽度。 可以设置width、height、margin、padding属性 inline-block 将对象呈现为内联对象，内容作为块级元素对象呈现，在同一行，可设置高宽，比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 摘自：http://www.cnblogs.com/KeithWang/p/3139517.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>inline</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF、XSS安全问题]]></title>
    <url>%2F2017%2F07%2F02%2F%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%2Fcsrf%E3%80%81xxs%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[XSS：跨站脚本攻击 原因：应用程序在接受数据之后没有进行适当的验证和转义，直接发送给网页浏览器，可能会长生XXS攻击。 危害：恶意的HTML/JavaScript代码会注入到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击。 防御方法： HttpOnly 。 浏览器禁止页面的JS访问带有HttpOnly属性的Cookie，从而保证安全。 输入检查 XSS Filter 。 对输入内容做格式检查，类似“白名单”，可以让一些基于特殊字符的攻击失效。 输出检查 。 在变量输出到html页面时，可以使用编码或转义的方式来防御XSS攻击。 对富文本进行处理 防御DOM Based XSS 如果是输出到事件或脚本，要做一次javascriptEncode；如果是输出到HTML内容或者属性，要做一次HtmlEncode。 CSRF：跨站请求伪造，XXS是实现CSRF的其中一种方法。 原因：XSS是利用用户对当前网站的信任来发起攻击，而CSRF是利用网站对用户的信任来发起攻击。重要操作的所有参数都是可以被攻击者猜测到的。攻击者预测出URL的所有参数与参数值，才能成功地构造一个伪造的请求，将使用用户浏览器向存在漏洞的应用程序发起请求。 防御方法： 验证码、 Referer Check 检查请求是否来自合法的源（可被伪造）。 对于任何重要的请求都需要重新验证用户的身份； 通用方法：使用Anti-CSRF Token 在URL中保持原参数不变，新增一个参数Token。Token的值是随机的（必须使用足够安全的随机数生成算法，或者采用真随机数生成器），其为用户与服务器所共同持有，可以放在用户的Session中，或者浏览器的Cookie中。 每次session使用同一个Token，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程]]></content>
      <categories>
        <category>前端综合</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe父子页面互相操作DOM]]></title>
    <url>%2F2017%2F07%2F01%2FjavaScript%2Fiframe%E7%88%B6%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%BA%92%E7%9B%B8%E6%93%8D%E4%BD%9CDOM%2F</url>
    <content type="text"><![CDATA[javaScript版本 主要通过contentWindow对象以及window.parent 父页面获取子页面的方式 iframe的contentWindow属性，代表iframe所在的window对象。 123456789101112131415//1. 获取iframe节点 var iframe = document.getElementById(&apos;iframeId&apos;); 或 var iframe = frames[&apos;iframeId&apos;]; 或 var iframe = window.frames[&apos;iframeId&apos;]; 或 var iframe = iframeId; //2. 然后获取iframe包含的document对象: IE浏览器： var cWindow = iframe.document; 其它浏览器： var cWindow = iframe.contentWindow.document; 或 var cWindow = iframe.contentDocument; 12345678910111213&lt;script type=&quot;text/javascript&quot;&gt; //some other operation frames[&apos;iframeId&apos;].onload = function () &#123; var childDocument = this.contentDocument || this.document; var div=childDocument.getElementById(&apos;divId&apos;); &#125; &lt;/script&gt; &lt;iframe id=&quot;iframeId&quot; src=&quot;iframe.html&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt;//子页面&lt;div id=&quot;divId&quot;&gt;&lt;/div&gt; 子页面获取父页面的方式 通过window.parent获取 123456789101112131415父页面&lt;div id-&quot;pDivId&quot;&gt;&lt;/div&gt;&lt;iframe src=&quot;iframe.html&quot; width=&quot;100&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt;//子页面&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; if (window.parent !== window.self) &#123; //当前窗口是子窗口 var parentDocument =window.parent.document; &#125; var pDiv=parentDocument.getElementById(&apos;pDivId&apos;); //some other operation &#125; &lt;/script&gt; Jquery版本 主要是通过 123$(window.frames[&quot;iframeChild&quot;].document).find() //父页面操作子页面$(window.parent.document).find()//子页面操作父页面 实质就是获取要操作的页面的document转换为Jquery对象 父页面操作子页面DOM1$(window.frames[&quot;iframeId&quot;].document).find(&apos;#divId&apos;) 子页面操作父页面DOM1$(window.parent.document).find(&apos;#pDivId&apos;) iframe优缺点iframe的优点： iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 iframe的缺点： 会产生很多页面，不容易管理。 会出现多个上下、左右滚动条，用户体验度差。 现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。 很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。 window 的 onload 事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发，延迟加载速度。 iframe在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。分析了这么多，现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。 iframe与frame的区别 frame不能脱离frameSet单独使用，iframe可以； frame不能放在body中，嵌套在frameSet中的iframe必需放在body中； 不嵌套在frameSet中的iframe可以随意使用； frame的高度只能通过frameSet控制；iframe可以自己控制，不能通过frameSet控制。 如果在同一个页面使用了两个以上的iframe，在IE中可以正常显示，在firefox中只能显示出第一个；使用两个以上的frame在IE和firefox中均可正常]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中typeof与instanceof用法小记]]></title>
    <url>%2F2017%2F07%2F01%2FjavaScript%2Fjs%E4%B8%ADtypeof%E4%B8%8Einstanceof%E7%94%A8%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[判断一个对象typeof用以获取一个变量或者表达式的类型，typeof一般只能返回如下几个结果：number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。如： 12alert(typeof (123));//typeof(123)返回&quot;number&quot;alert(typeof (&quot;123&quot;));//typeof(&quot;123&quot;)返回&quot;string&quot; 我们可以使用typeof来获取一个变量是否存在，如if(typeof a!=”undefined”){}，而不要去使用if(a)因为如果a不存在（未声明）则会出错，正因为typeof遇到null,数组,对象时都会返回object类型，所以当我们要判断一个对象是否是数组时或者判断某个变量是否是某个对象的实例则要选择使用另一个关键语法instanceof。 instanceof用于判断一个变量是否某个对象的实例，如 1var a=new Array();alert(a instanceof Array); 会返回true，同时alert(a instanceof Object)也会返回true;这是因为Array是object的子类。再如： 1function test()&#123;&#125;;var a=new test();alert(a instanceof test)//会返回true。 也可以使用Object.prototype.toString.call()来判断数据类型，过程是1、获取对象的类名（对象类型）。2、然后将[object、获取的类名、]组合并返回。 1234567891011console.log(Object.prototype.toString.call(123)) //[object Number]console.log(Object.prototype.toString.call(&apos;123&apos;)) //[object String]console.log(Object.prototype.toString.call(undefined)) //[object Undefined]console.log(Object.prototype.toString.call(true)) //[object Boolean]console.log(Object.prototype.toString.call(&#123;&#125;)) //[object Object]console.log(Object.prototype.toString.call([])) //[object Array]console.log(Object.prototype.toString.call(function()&#123;&#125;)) //[object Function]&quot;Arguments&quot;, &quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Error&quot;, &quot;Function&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot; instanceof运算符定义是1234567891011function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式 var O = R.prototype;// 取 R 的显示原型 L = L.__proto__;// 取 L 的隐式原型 while (true) &#123; if (L === null) return false; if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true return true; L = L.__proto__; &#125; &#125; 其中proto指向的是当前对象的原型对象，prototype指向它的构造函数的原型对象 12345678Object.__proto__ = Function.prototype？答：truefunction func()&#123;&#125;func.__proto__ == Function.prototype;//trueFunction.__proto__ == Function.prototype;//trueArray.__proto__ == Function.prototype;//trueObject.__proto__ == Function.prototype;//trueFunction.prototype.__proto__ == Object.prototype;//trueObject.prototype.__proto__ == null//true 12345function Foo()&#123;&#125;Foo.prototype = new Aoo();//JavaScript 原型继承var foo = new Foo();console.log(foo instanceof Foo)//trueconsole.log(foo instanceof Aoo)//true 上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。 又如： 123456console.log(Object instanceof Object);//trueconsole.log(Function instanceof Function);//true console.log(Number instanceof Number);//falseconsole.log(String instanceof String);//falseconsole.log(Function instanceof Object);//trueconsole.log(Foo instanceof Function);//trueconsole.log(Foo instanceof Foo);//false 12345678910111213141、Object instanceof Object// 为了方便表述，首先区分左侧表达式和右侧表达式ObjectL = Object, ObjectR = Object; // 下面根据规范逐步推演O = ObjectR.prototype = Object.prototype L = ObjectL.__proto__ = Function.prototype //Console.log(Object) 为function Number()// 第一次判断O != L // 循环查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O == L // 返回 true 1234567892、 Function instanceof Function// 为了方便表述，首先区分左侧表达式和右侧表达式FunctionL = Function, FunctionR = Function; // 下面根据规范逐步推演O = FunctionR.prototype = Function.prototype L = FunctionL.__proto__ = Function.prototype // 第一次判断O == L // 返回 true 123456789101112131415163.Number instanceof NumberNumberL = Numebr,NumberR = NumberO = NumberR.prototype = Number.prototypeL = NumberL._proto_ = Function.prototype//Console.log(Number) 为function Number()O != L // 循环再次查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O != L // 再次循环查找 L 是否还有 __proto__ L = Object.prototype.__proto__ = null // 第三次判断L == null // 返回 false同理 Boolean String 都是false 12345678910111213141516174、Foo instanceof Foo// 为了方便表述，首先区分左侧表达式和右侧表达式FooL = Foo, FooR = Foo; // 下面根据规范逐步推演O = FooR.prototype = Foo.prototype L = FooL.__proto__ = Function.prototype // 第一次判断O != L // 循环再次查找 L 是否还有 __proto__ L = Function.prototype.__proto__ = Object.prototype // 第二次判断O != L // 再次循环查找 L 是否还有 __proto__ L = Object.prototype.__proto__ = null // 第三次判断L == null // 返回 false ```]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>typeof and instanceof</tag>
      </tags>
  </entry>
</search>