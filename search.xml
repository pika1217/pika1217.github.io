<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[伪类]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2FCSS%2BCSS3%20%E4%BC%AA%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[伪类语法1selector : pseudo-class &#123;property: value&#125; CSS 类也可与伪类搭配使用1selector.class : pseudo-class &#123;property: value&#125; 锚伪类1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ first-child类12p:first-child &#123;font-weight: bold;&#125;li:first-child &#123;text-transform:uppercase;&#125; 第一个规则将作为某元素第一个子元素的所有 p 元素设置为粗体。第二个规则将作为某个元素（在 HTML 中，这肯定是 ol 或 ul 元素）第一个子元素的所有 li 元素变成大写。 属性 描述 :active 向被激活的元素添加样式。 :focus 向拥有键盘输入焦点的元素添加样式。 :hover 当鼠标悬浮在元素上方时，向元素添加样式。 :link 向未被访问的链接添加样式。 :visited 向已被访问的链接添加样式。 :first-child 向元素的第一个子元素添加样式。 注：1234p:first-child //选择所有元素的子元素中第一个p元素p &gt; i:first-child //选择所有p元素的子元素中的第一个i元素p:first-child i // 选择所有作为第一个子元素的 &lt;p&gt; 元素中的所有 &lt;i&gt; 元素p:nth-type-of(n) //匹配是p元素的父元素的第 n 个p子元素 css3新增伪类2、CSS3新增伪类 新增伪类 作用 p:first-of-type 选择每个含有元素作为直接子元素的父元素的子元素中首个元素。 p:last-of-type 选择每个含有元素作为==直接子元素==的父元素的子元素中的最后一个个元素。 p:only-of-type 选择每个含有唯一一个元素作为直接子元素的其父元素下的唯一的那个元素。 p:only-child 选择==后代元素==中只有一个元素的元素唯一的子元素元素。 p:nth-child(n)| 先选择每个p元素的直接父元素，再选择每个父元素其下的第n个子元素，若子元素是p元素则选中。n可以是数字，表达式，奇偶 p:nth-last-child(n)|选择属于其父元素的倒数第n个子元素的每个元素。p:nth-of-type(n)| 先选择每个p元素的直接父元素，再选择每个父元素下的第n个p子元素，如果有则选中。n可以是数字，表达式，奇偶p:nth-last-of-type(n) |选择属于其父元素倒数第n个元素的每个元素。p:last-child|选择属于其父元素最后一个子元素的每个元素。p:empty|选择没有子元素的每个元素（包括文本节点）。p:target |选择当前活动的元素。:not(p)|选择非元素的每个元素。:enabled|控制表单控件的可用状态。:disabled |控制表单控件的禁用状态。:checked |单选框或复选框被选中。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>伪类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9-CSS%2F</url>
    <content type="text"><![CDATA[CSS常见兼容性问题总结 原文 http://www.cnblogs.com/imwtr/p/4340010.html 浏览器的兼容性问题，通常是因为不同的浏览器对同一段代码有不同的解析，造成页面显示不统一的情况。这里谈到的浏览器，主要指IE6/IE7/IE… FireFox Chrome Opera Safari 等。 但更多的兼容还是考虑IE6/IE7/FF之间的斗争先来谈谈CSS Hack我们为了让页面形成统一的效果，要针对不同的浏览器或不同版本写出对应可解析的CSS样式，所以我们就把这个针对不同浏览器/版本而写CSS的过程叫做 CSS hack. CSS hack主要有三种：IE条件注释法、CSS属性前缀法、选择器前缀法。 IE条件注释法即在正常代码之外添加判别IE浏览器或对应版本的条件注释，符合条件的浏览器或者版本号才回执行里边的代码。 12345678910&lt;!-- lt是小于 gt是大于 lte是小于等于 gte是不小于 !是不等于 --&gt;&lt;!-- [if IE]&gt; 你想要执行的代码 &lt;![endif]--&gt;&lt;!-- [if lt IE 8]&gt; 你想要执行的代码 &lt;![endif]--&gt;&lt;!-- [if ! IE 8]&gt; 你想要执行的代码 &lt;![endif]--&gt; CSS属性前缀法即是给css的属性添加前缀。比如 * 可以被IE6/IE7识别，但 只能被IE6识别，IE6-IE10都可以识别 “\9”，IE6不能识别!important FireFox不能识别* \9可以先使用“\9”标记，将IE分离出来，再用”*”分离出IE6/IE7，最后可以用“_”分离出IE6 1234567.type&#123; color: #111; /* all */ color: #222\9; /* IE */ *color: #333; /* IE6/IE7 */ _color: #444; /* IE6 */ &#125; 所以可以按着优先级就能给特定的版本捎上特定颜色一般来说，只有IE6不支持 !important 所以可以这样 1234#example&#123; width: 100px !important; /* IE7 FF */ width: 110px; /* IE6 */&#125; 因为!important 具有最高优先级，所以此种方式可以区别出来~为什么说一般呢…你看看下面这个例子，IE6貌似还认得出!important 12345h1&#123;color: #f00 !important; &#125;h1&#123;color: #000;&#125;h2&#123;color: #f00 !important; color: #000;&lt;h1&gt;test1&lt;/h1&gt;&lt;h2&gt;test2&lt;/h2&gt; 选择器前缀法，顾名思义，就是给选择器加上前缀IE6可识别 div{color:red;}IE7可识别 +div{color:red;} 其它兼容问题 最主要也是最常见的，就是浏览器对标签的默认支持不同，所以我们要统一，就要进行CSS reset . 最简单的初始化方法是 *{margin:0; padding:0;},但不推荐，而且它也并不完善。 贴一个淘宝的样式初始化~ body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } IE6双边距bug:块属性标签添加了浮动float之后，若在浮动方向上也有margin值，则margin值会加倍。其实这种问题主要就是会把某些元素挤到了第二行 1234567891011121314&lt;style type=&quot;text/css&quot;&gt; html,body,div&#123; margin: 0;padding: 0;&#125; .wrap&#123;width: 200px; height: 200px; border: 1px solid #333;&#125; .box&#123;float: left; /* display:inline */ ;margin-left: 10px; width: 80px; height: 80px; background-color: green;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt; IE6下左边的双边距 ~ IE7的没问题 ~ 解决的方式有两个： 给float元素添加display：inline 即可正常显示 就是hack处理了，对IE6进行 _margin-left:5px; 跟上述差不多，也属于IE6双边距bug:行内属性标签，为了设置宽高，我们经常就会设置成display：block; 这样一来就产生上述的问题。解决办法也是isplay：inline;但是这样一来我们就不能设置宽高了，所以呢需要再加个display:table.所以你设置display:block后，再添上display:inline和display:table 上下margin重合问题，相邻的两个div margin-left margin-right 不会重合，但相邻的margin-top margin-bottom会重合。 123456.box1&#123;width: 200px;height: 200px; border: 1px solid #333; &#125; .mt&#123;margin-top: 10px;&#125; .mb&#123;margin-bottom: 10px;&#125;&lt;div class=&quot;box1 mb&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box1 mt&quot;&gt;&lt;/div&gt; 解决办法就是不要同时采用top和bottom ,统一一些~ 有些浏览器解析img标签也有不同，img是行内的，一般都会紧接着排放，但是在有些情况下还是会突然出现个间距，解决办法是给它来个浮动float 标签属性min-height是不兼容的，所以使用的时候也要稍微改改。 1.box&#123;min-height:100px;height:auto !important; height:100px; overflow:visible;&#125; 另一方面，IE是不支持min-height这类属性的，所以有些时候也可以考虑使用CSS表达式 12345#container&#123; min-width:600px; width: expression(document.body.clientWidth &lt; 600? &quot;600px&quot;:&quot;auto&quot;);&#125; 很多时候可能会纳闷超链接访问过后样式就混乱了，hover样式不出现了。其实主要是其CSS属性的排序问题。一般来说，最好按照这个顺序：L-V-H-A 简单的记法是 love hate 1a:link&#123;&#125; a:visited&#123;&#125; a:hover&#123;&#125; a:active&#123;&#125; chrome下默认会将小于12px的文本强制按照12px来解析。解决办法是给其添加属性： 1-webkit-text-size-adjust: none; png24位的图片在IE6下面会出现背景，所以最好还是使用png8格式的 因为存在两种盒子模式：IE盒子模式和W3C标准模式，所以对象的实际宽度也要注意。 IE/Opera：对象的实际宽度 = (margin-left) + width + (margin-right)Firefox/Mozilla：对象的实际宽度= (margin-left) + (border-left-width) + (padding- left) + width + (padding-right) +(border-right-width) + (margin-right) 鼠标的手势也有问题：FireFox的cursor属性不支持hand，但是支持pointer，IE两个都支持；所以为了兼容都用pointer 消除ul、ol等列表的缩进时，样式应写成: 1list-style:none;margin:0px;padding:0px; 其中margin属性对IE有效，padding属性对FireFox有效 CSS控制透明度问题：一般就直接 opacity: 0.6 ; IE就 filter: alpha(opacity=60)但在IE6下又有问题，所以又得弄成 filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60); 有些时候图片下方会出现一条间隙，通常会出现在FF和IE6下面比如 1&lt;div&gt;&lt;img src=&quot;1.jpg&quot;/&gt;&lt;/div&gt; 一般给img添加vertical-align属性即可，比如top middle 1img&#123;verticle-align:center;&#125; IE6下div高度无法小于10px,比如定义一条高2px的线条，FF和IE7都正常但IE6就是10px解决的办法有两种：添加overflow属性或设置fontsize大小为高度大小 如： 123&lt;div style=&quot;height:2px;overflow:hidden;background:#000000;width:778px;&quot;&gt;&lt;/div&gt;&lt;div style=&quot;height:2px;font-size:2px;background:#000000;width:778px;&quot;&gt;&amp;nbps;&lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浏览器兼容</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器内核及CSS适配]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E4%BB%A5%E5%8F%8Acss%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[各浏览器内核 Webkit内核：使用此引擎内核的浏览器有：Safari(包括移动版和桌面版)、Chrome。其私有属性的前缀是-webkit-。 Gecko内核：使用此引擎内核的浏览器有Mozilla，常指的是Firefox浏览器。其私有属性的前缀是-moz-。 Presto内核：使用此引擎内核的浏览器是指Opera。其私有属性的前缀是-o-。 KHTML内核：使用此引擎内核的浏览器是指Konqueror。其私有属性的前缀是-khtml-。 Trident内核：使用此引擎内核的浏览器是IE浏览器。其私有属性的前缀是-ms-。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>浏览器内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[原理float属性会使得普通元素脱离稳定流变成浮动元素。 存在的问题浮动的子元素显示在父容器的外部 原因在CSS规范中，浮动定位不属于正常的页面流（page flow），是独立定位的。所以，只含有浮动元素的父容器，在显示时不考虑子元素的位置，就当它们不存在一样。这就造成了显示出来，父容器好像空容器一样。 解决办法添加空元素12345&lt;div&gt; &lt;div style=&quot;float:left;width:45%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;float:right;width:45%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 原理是父容器现在必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了。这种方法比较简单，但是要在页面中增加冗余标签，违背了语义网的原则。 浮动的容器索性将父容器也改成浮动定位，这样它就可以带着子元素一起浮动了。 1234&lt;div style=&quot;float:left;&quot;&gt; &lt;div style=&quot;float:left;width:45%;&quot;&gt;&lt;/div&gt; &lt;div style=&quot;float:right;width:45%;&quot;&gt;&lt;/div&gt; &lt;/div&gt; 缺点在于父容器变成浮动以后，会影响到后面元素的定位，而且有时候，父容器是定位死的，无法变成浮动。 浮动元素的自动clearing，触发BFC规则，不仅仅是overflow让父容器变得可以自动”清理”（clearing）子元素的浮动，从而能够识别出浮动子元素的位置，不会出现显示上的差错。要做到这点，只要为父容器加上一条”overflow: hidden”的CSS语句就行了。缺点主要有两个，一个是IE6不支持，另一个是一旦子元素的大小超过父容器的大小，就会出显示问题,溢出的子元素会被裁剪掉。 通过CSS语句添加子元素不用修改HTML代码有一个:after伪选择符，就可以在父容器的尾部自动创建一个子元素。 123456.clearfix:after &#123; content: &quot;\0020&quot;; display: block; height: 0; clear: both; &#125; 其中的”clearfix”是父容器的class名称，”content:”020”;”是在父容器的结尾处放一个空白字符，”height: 0;”是让这个这个空白字符不显示出来，”display: block; clear: both;”是确保这个空白字符是非浮动的独立区块。但是，:after选择符IE 6不支持，也就是说上面的这段代码在IE 6中无效，这怎么办？我们添加一条IE 6的独有命令”zoom:1;”就行了，这条命令的作用是激活父元素的”hasLayout”属性，让父元素拥有自己的布局。IE 6会读取这条命令，其他浏览器则会直接忽略它。123456789101112131415161718192021222324252627.clearfix:after &#123;content: &quot;\0020&quot;;display: block;height: 0;clear: both;&#125;.clearfix &#123;zoom: 1;&#125;通用代码/* For modern browsers */.cf:before,.cf:after &#123; content:&quot;&quot;; display:block;&#125;.cf:after &#123; clear:both;&#125;/* For IE 6/7 (trigger hasLayout) */.cf &#123; zoom:1;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>清除浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪元素]]></title>
    <url>%2F2017%2F07%2F10%2FCSS%2FCSS%20%E4%BC%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[伪元素12selector:pseudo-element &#123;property:value;&#125;selector.class:pseudo-element &#123;property:value;&#125; ::first-line伪元素 用于向文本的首行设置特殊样式12345p:first-line &#123; color:#ff0000; font-variant:small-caps; &#125; ::first-letter伪元素 用于向文本的首字母设置特殊样式12345p:first-letter &#123; color:#ff0000; font-size:xx-large; &#125; 上述两类只能用于块元素 伪类和伪元素配合1234p.article:first-letter &#123; color: #FF0000; &#125; ::before 伪元素 在元素的内容前面插入新内容。 ::after 伪元素在元素的内容后面插入新内容。 属性 描述 ::first-letter 向文本的第一个字母添加特殊样式。 ::first-line 向文本的首行添加特殊样式。 ::before 在元素之前添加内容。 ::after 在元素之后添加内容。 ::selection(CSS3新增) 给选中文本添加效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>伪元素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分布局浅析]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #parent&#123; width:100px; height:100px; background-color: #eee; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;parent&quot;&gt; &lt;div id=&quot;child&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 水平居中 方法一：margin:0 auto; （最常用的居中布局方式,元素宽度已知（块级元素有宽度，内联元素有内容）,未浮动，一定是用在元素本身不是父元素。父元素如果是块级元素则不用设置width默认占据一行。父元素如果是内联元素则需要display:inline-block,再设置宽度。如果是多个内联元素或者多个块级元素，则需要都放在一个块级元素里再使用此方法。因为设置完了display: inline-block 之后margin：0 auto无效了，或者直接使用第二种方法。 text-align和inline-block的结合（设置父元素的text-align为center）。这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。多个块级元素水平排列居中布局时更适合选用这种方法。 position绝对定位来实现。适用于块级元素不给出宽高的情况下==(需要借助transtrom的tanslateX方法)，当又需要对多个child进行居中时需要在child外层再加一个div并对其进行定位。 12345678910111213 #parent&#123; position: relative;&#125; #child&#123; position: absolute; left: 50%; top: 0; -ms-transform: translate(-50%,-50%); -moz-transform: translate(-50%,-50%); -o-transform: translate(-50%,-50%); transform: translate(-50%,-50%); background-color: #ccc;&#125; 利用flex弹性布局的一个属性子元素是否有宽度不重要 1234body&#123; display: flex; justify-content:center; &#125; 浮动实现水平居中的方法 12345678910111213141516171819202122232425.child&#123; float: left; position: relative; right: 50%; &#125; #part&#123; float:left; width:100%; overflow: hidden; position: relative; &#125; #part2&#123; clear: left; float: left; position: relative; left:50%; &#125; &lt;div id=&quot;part&quot;&gt; &lt;div id=&quot;part2&quot;&gt; &lt;div class=&quot;child&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;thr&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;four&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS3的fit-content实现水平居中方法居中一个浮动元素 123456789.child&#123; float: left; &#125; #part2&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; 水平垂直居中 文字垂直居中： height:50px; line-height:50px; overflow:hidden; 1234567891011121314151617181920211 子元素 div 绝对定位 2 父元素需要被定位 3 子元素 top、bottom、left、right 四个位置值均为 0 4 子元素 margin: auto; #parent&#123; width: 100%; height:100%; position: fixed; &#125; #child&#123; width: 200px; height: 100px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; background-color: #ccc; &#125; 利用position的绝对定位及负外边框距来实现。 123456789101112131415#parent&#123; position: fixed; width: 100%; height: 100%; &#125; #child&#123; position: absolute; left: 50%; top: 50%; width: 400px; height: 200px; margin-top: -height/2px; margin-left: -width/2px; background-color: #ccc; &#125; 对于未给出宽高的元素，又需要运用transform并且运用绝对定位和正外边距来实现。 123456789#parent&#123; position: relative; &#125; #child&#123; position: absolute; left: 50%; top: 50%; transform:translate(-50%,-50%); &#125; 运用flex布局，要给父元素一个高度，不然无法垂直居中 12345678#parent&#123; display: flex; justify-content:center; height:100%; &#125; #child&#123; align-self:center; &#125; 左边固定，右边自适应的两列布局方式一：float+margin 需要清除浮动 1234567#left&#123; float: left; width: 100px; &#125; #right&#123; margin-left: 120px; &#125; 方式二：float+overfloww 不用清除浮动 123456#left&#123; float: left; width: 100px; margin-right: 20px; &#125; #right&#123; overflow: hidden; &#125; 方式三：float+margin+position 123456789101112131415#parent&#123; position: relative; &#125; #left&#123; float: left; width: 100px; background-color: #ccc; &#125; #right&#123; position: absolute; top: 0; left: 120px; background-color:pink; &#125; 方式四：flex 12345678#parent&#123; display: flex; &#125; #left&#123; width: 100px; margin-right: 20px; &#125; #right&#123; flex: 1; &#125; 右边固定，左边自适应的两列布局 –与3类似两边固定中间自适应方式一：使用float 1234.left&#123; float: left; width: 200px; height: 200px; &#125; .right&#123; float: right; width: 100px; height: 100px; &#125; .middle&#123; margin:0 120px 0 220px; &#125;** 关键是html中中间的div放在最后，不然right div会距离上部有空隙 方式二：position绝对定位 1234.parent&#123; position: relative; &#125; .left&#123; position: absolute; width: 200px; height: 200px; top: 0; left: 0; &#125; .right&#123; position: absolute; top: 0; right: 0; width: 100px; height: 100px; &#125; .middle&#123; margin:0 120px 0 220px; &#125; 方式三：flex 1234.parent&#123; display: flex; &#125; .left&#123; width: 200px; height: 200px; &#125; .right&#123; width: 100px; height: 100px; &#125; .middle&#123; flex: 1; margin:0 20px; &#125; 方式四：margin负值法123456789101112131415161718192021222324252627#main&#123; width: 100%; float: left;&#125;#main #body&#123; margin: 0 120px; background-color: #ffe6b8;&#125;#left,#right&#123; width:100px; height: 100%; float: left; background-color: #a0b3d6;&#125; #left&#123; margin-left: -100%; &#125;#right&#123; margin-left: -100px; &#125;&lt;div class=&quot;fourth&quot;&gt;&lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt;&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;/div&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3新特性]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2FCSS3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[CSS3的新特性整理animation IE10+animation的六大属性 animation-name规定需要绑定选择器的keyframe名称 animation-duration规定完成动画所花费的时间 s ms ，object.style.animationDuration=”3s” animation-timing-function动画的速度曲线，默认值ease，object.style.animationTimingFunction=”linear”，语法 animation-timing-function:value animation-timing-function使用名为三次Cubic Bezier贝塞尔曲线函数的数学函数，来生成速度曲线 可以使用自己的值也可 以预定义的值 值:linear从始到末以相同的速度 ease 默认 从低速 加快在结束前变慢 ease-in动画低速开始 ease-out动画低速结束 ease-in-out动画从低速开始和结束 cubic-bezier(n,n,n,n)在 cubic-bezier 函数中自己的值。可能的值是从 0 到 1 的数值 animation-deplay动画开始之前的延迟 animation-delay: time; JavaScript 语法：object.style.animationDelay=&quot;2s&quot; animation-delay 值以秒或毫秒计。 允许负值，-2s 使动画马上开始，但跳过 2 秒进入动画 animation-iteration-count动画播放的次数 IE10 animation-iteration-count: n|infinite JavaScript 语法： object.style.animationIterationCount=3 animation-direction是否应该轮流反向播放动画 animation-direction 值是 &quot;alternate&quot;，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等等 ）向后播放 animation-direction: normal|alternate; JavaScript 语法： object.style.animationDirection=&quot;alternate&quot; 默认值 none 0 ease 0 1 normal javascript的语法 object.style.animation=&quot;mymove 5s infinite&quot; 123456789101112131415161718192021div&#123;width:100px;height:100px;background:red;position:relative;animation:mymove 5s infinite;-webkit-animation:mymove 5s infinite; /*Safari and Chrome*/&#125;@keyframes mymove&#123;from &#123;left:0px;&#125;to &#123;left:200px;&#125;&#125;@-webkit-keyframes mymove /*Safari and Chrome*/&#123;from &#123;left:0px;&#125;to &#123;left:200px;&#125;&#125; Transition 过渡的四大属性 IE10+transition-propertytransiont-property属性规定过渡css属性的名称transition-property: none|all|propertyCSS 属性名称列表，列表以逗号分隔;JavaScript 语法： object.style.transitionProperty=”width,height” transition-duration完成过渡效果需要多少秒或毫秒transition-duration: time;JavaScript 语法： object.style.transitionDuration=”5s” transition-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);JavaScript 语法： object.style.transitionTimingFunction=”linear” transition-delayJavaScript 语法： object.style.transitionDelay=”2s”transition-delay: time; 默认值 all 0 ease 0transition:property duration timing-function delayjavascript语法：object.style.transition=”width 2s” 123456789101112131415div&#123;width:100px;height:100px;background:blue;transition:width 2s;-moz-transition:width 2s; /* Firefox 4 */-webkit-transition:width 2s; /* Safari and Chrome */-o-transition:width 2s; /* Opera */&#125;div:hover&#123;width:300px;&#125; transform IE10transform 允许我们对元素进行旋转、缩放、移动、或倾斜默认nonejavascript的语法 object.style.transform=”rotate(7deg)”transform: none|transform-functions; none 不进行转换matrix(n,n,n,n,n,n)使用六个值的矩阵matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)使用 16 个值的 4x4 矩阵translate(x,y)2D 转换translate3d(x,y,z)3D 转换translateX(x)只是用 X 轴的值translateY(y)只是用Y轴的值translateZ(z)只是用Z轴的值scale(x,y)2D缩放scale3d(x,y,z)3D缩放scaleX(x),scaleY(y),scaleZ(z)rotate(angle) 2D 旋转，在参数中规定角度rotate3d(x,y,z,angle)3D 旋转rotateX(angle),rotateY(angle),rotateZ(angle)skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换skewX(angle) skewY(angle) perspective(n) 新增的css3的选择器 1234567891011121314151 E:nth-last-child(n) 2 E:nth-of-type(n) 3 E:nth-last-of-type(n) 4 E:last-child 5 E:first-of-type 6 E:only-child 7 E:only-of-type 8 E:empty 9 E:checked 10 E:enabled 11 E:disabled 12 E::selection 13 E:not(s) 14 E::not(.s) 15 body: nth-child(even), nth-child(odd)/*：此处他们分别代表了表格（tbody）下面的偶数行和奇数行（tr）*/等等...... @Font-face 特性Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体 Font-face 客户端字体案例 arial courier verdana Font-face 服务端字体案例 12345678910111 @font-face &#123; 2 font-family: BorderWeb; 3 src:url(BORDERW0.eot); 4 &#125; 5 @font-face &#123; 6 font-family: Runic; 7 src:url(RUNICMT0.eot); 8 &#125; 9 10 .border &#123; FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: &quot;BorderWeb&quot; &#125; 11 .event &#123; FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: &quot;Runic&quot; &#125; Word-wrap设置或检索当当前行超过指定容器的边界时是否断开转行，文字此时已被打散Text-overflow它与 word-wrap 是协同工作word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow则设置或检索当当前行超过指定容器的边界时如何显示 1 .clip{text-overflow:clip; overflow:hidden; white-space:nowrap;2 width:200px;background:#ccc;}3 .ellipsis{text-overflow:ellipsis; overflow:hidden; white-space:nowrap;4 width:200px; background:#ccc;} 1 不显示省略标记，而是简单的裁切条23 当对象内文本溢出时显示省略标记 文本渲染 1 div {2 -webkit-text-fill-color: black;3 -webkit-text-stroke-color: red;4 -webkit-text-stroke-width: 2.75px;5 } Text-fill-color: 文字内部填充颜色Text-stroke-color: 文字边界填充颜色Text-stroke-width: 文字边界宽度 gradient 渐变效果线性渐变 linear左上（0% 0%）到右上(0% 100%) background-image:-webkit-gradient(linear,0% 0%,100% 0%,form(red),to(balck)) background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),color-stop(0.33,#AAD010),color-stop(0.33,#FF7F00),to(#FE280E)); 径向渐变radial从一个圆到一个圆的渐变background:-weblit-gradient(radial,50 50,50,50 50,0,form(black),color-stop(0.5,red),to(blue)); css3的阴影shadow和反射reflect background-clip:border-box;背景从border开始显示；background-clip：padding-boxbackground-clip：content-boxbackground-clip:no-clip:no-clicp默认属性等同于border-box background-origin 用于确定背景的位置 通常与background-positon联合使用 background-size来调整背景图片的大小，注意别和 clip 弄混，这个主要用于设定图片本身 background-size: contain; 缩小图片以适合元素（维持像素长宽比）background-size: cover; 扩展元素以填补元素（维持像素长宽比）background-size: 100px 100px; 缩小图片至指定的大小 .background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元 素没有分成多个盒子，依然是一个整体一 样）background-break: bounding-box; 把盒之间的距离计算在内；background-break: each-box; 为每个盒子单独重绘背景 counter()=[counter(name) | counters(name,list-style-type)]{1,} counter-reset IE8 counter-reset 属性设置某个选择器出现次数的计数器的值。默认为 0。利用这个属性，计数器可以设置或重置为任何值，可以是正值或负值。如果没有提供 number，则默认为 0。注释：如果使用 “display: none”，则无法重置计数器。如果使用 “visibility: hidden”，则可以重置计数器 JavaScript 语法： object.style.counterReset=”subsection” counter-reset的值none id number inherit attr()=attr(attr-name)插入元素的属性值 IE8 calc() =calc(四则运算) 动态计算长度值 IE9需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；calc()函数支持 “+”, “-“, “*”, “/“ 运算；calc()函数使用标准的数学运算优先级规则； initial属于css-wide关键字，这表示所有的属性都可以接受该值 IE11 unset 擦除属性声明 颜色值color color的颜色名称，HEX，RGB，RGBA，HSL，HSLA，transparent,currentColor currentColor resolution分辨率值不允许有负值频率单位包括有： dpi, dpcm, dppx 角度值 angle角度值的正常范围应在[0-360deg]内，例如：-10deg与350deg是等价的角度单位包括有： deg, grad一个圆共400梯度, rad 一个圆共2π弧度, turn90deg = 100grad = 0.25turn ≈ 1.570796326794897rad 长度值与单位ch 数字“0”的宽度 ie9 rem 相对长度单位。相对于根元素(即html元素)font-size计算值的倍数 vw 相对于视口的宽度。视口被均分为100单位的vw ie9 vh 相对于视口的高度。视口被均分为100单位的vh vmax 相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax vmin 相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin q 1/4毫米（quarter-millimeters）。绝对长度单位。 1in = 2.54cm = 25.4 mm = 101.6q = 72pt = 6pc = 96px @import@media@font-face@keyframes@supports CSS3 的盒子模型盒子模型为开发者提供了一种非常灵活的布局方式，但是支持这一特性的浏览器并不多，目前只有 webkit 内核的新版本 safari 和 chrome 以及 gecko 内核的新版本 firefox]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其它布局方式]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E5%85%B6%E5%AE%83%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[网格布局基本网格布局-平分布局空间HTML代码如下。 12345&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;/div&gt; CSS代码如下。 1234567.Grid &#123; display: flex; &#125; .Grid-cell &#123; flex: 1; &#125; 百分比布局某个网格宽度固定百分比，其余网格平均分配剩余空间 HTML代码如下。 123456789101112131415161718192021222324252627282930&lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of2&quot;&gt;...&lt;/div&gt; &lt;/div&gt; .Grid &#123; display: flex; &#125; .Grid-cell &#123; flex: 1; = flex:1 1 0% &#125; .Grid-cell.u-full &#123; flex: 0 0 100%; &#125; .Grid-cell.u-1of2 &#123; flex: 0 0 50%; &#125; .Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%; &#125; .Grid-cell.u-1of4 &#123; flex: 2 0 25%; &#125; 计算方法：先算占比50%+25% = 75%flex-basis都是按总宽度来算，f2占总宽度50%，f4占总宽度25%，剩余25%分成3份，Grid-cell占三分之一，f4占三分之二。 圣杯布局 页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。HTML代码如下： 123456789&lt;body class=&quot;HolyGrail&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;div class=&quot;HolyGrail-body&quot;&gt; &lt;main class=&quot;HolyGrail-content&quot;&gt;...&lt;/main&gt; &lt;nav class=&quot;HolyGrail-nav&quot;&gt;...&lt;/nav&gt; &lt;aside class=&quot;HolyGrail-ads&quot;&gt;...&lt;/aside&gt; &lt;/div&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt; CSS代码如下： 1234567891011121314151617181920212223242526272829.HolyGrail &#123; display: flex; min-height: 100vh;//浏览器视口的高度 flex-direction: column; &#125; header, footer &#123; flex: 1; &#125; .HolyGrail-body &#123; display: flex; flex: 1; &#125; .HolyGrail-content &#123; flex: 1; &#125; .HolyGrail-nav, .HolyGrail-ads &#123; /* 两个边栏的宽度设为12em */ flex: 0 0 12em; &#125; .HolyGrail-nav &#123; /* 导航放到最左边 */ order: -1; &#125; 悬挂式布局主栏的左侧或右侧，需要添加一个图片栏HTML代码如下。 1234&lt;div class=&quot;Media&quot;&gt; &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;Media-body&quot;&gt;...&lt;/p&gt; &lt;/div&gt; CSS代码如下。 123456789101112.Media &#123; display: flex; align-items: flex-start; &#125; .Media-figure &#123; margin-right: 1em; &#125; .Media-body &#123; flex: 1; &#125; 固定的底栏HTML代码如下。 12345&lt;body class=&quot;Site&quot;&gt; &lt;header&gt;...&lt;/header&gt; &lt;main class=&quot;Site-content&quot;&gt;...&lt;/main&gt; &lt;footer&gt;...&lt;/footer&gt; &lt;/body&gt; CSS代码如下。 123456789.Site &#123; display: flex; min-height:100vh;//视口默认被均分为100vh flex-direction: column; &#125; .Site-content &#123; flex: 1; &#125; 流式布局每行项目数固定，会自动分行123456789101112131415.parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-wrap: wrap; align-content: flex-start; &#125;.child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red; &#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平居中布局]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[margin:0 auto;（最常用的居中布局方式,元素宽度已知（块级元素有宽度，内联元素有内容）,未浮动，一定是用在元素本身不是父元素。父元素如果是块级元素则不用设置width默认占据一行。父元素如果是内联元素则需要display:inline-block,再设置宽度。如果是多个内联元素或者多个块级元素，则需要都放在一个块级元素里再使用此方法。因为设置完了display: inline-block 之后margin：0 auto无效了，或者直接使用第二种方法。 text-align和inline-block的结合（设置父元素的text-align为center）。这种方式最好应用于图片、按钮、文字之类的居中模式，否则就需要借助inline-block来进行居中布局。多个块级元素水平排列居中布局时更适合选用这种方法。 position绝对定位来实现居中布局。适用于块级元素不给出宽高的情况下(需要借助transtrom的tanslateX方法)，当又需要对多个child进行居中时需要在child外层再加一个div并对其进行定位。 #parent{ position: relative; } #child{ position: absolute; left: 50%; top: 0; -ms-transform: translate(-50%); -moz-transform: translate(-50%); -o-transform: translate(-50%,); transform: translate(-50%); background-color: #ccc; } 利用flex弹性布局的一个属性子元素是否有宽度不重要body{ display: flex; justify-content:center; } 浮动实现水平居中的方法12345678910111213141516171819202122232425.child&#123; float: left; position: relative; right: 50%; &#125; #part&#123; float:left; width:100%; overflow: hidden; position: relative; &#125; #part2&#123; clear: left; float: left; position: relative; left:50%; &#125; &lt;div id=&quot;part&quot;&gt; &lt;div id=&quot;part2&quot;&gt; &lt;div class=&quot;child&quot;&gt;one&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;two&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;thr&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;four&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS3的fit-content实现水平居中方法居中一个浮动元素 123456789.child&#123; float: left; &#125; #part2&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; 以下例子中除了第一种方式需要给宽度，其它方式都能不给宽度。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt; .first-way&#123; width:100px; height: 100px; background-color: red; margin: 0 auto; &#125; .second-way&#123; width:100%; text-align: center; overflow: hidden;//实际是没有的 &#125; .second-child&#123; display: inline-block; width:100px; height:100px; background-color: red; &#125; .third-way&#123; position: absolute; left:50%; top:0%; /*默认应该是0%*/ transform:translateX(-50%); /*向左移动元素宽度的一半长度*/ width:300px; height:100px; border: 1px solid green; &#125; .fourth-way&#123; display: flex; justify-content:center; &#125; .fourth-way &gt; div&#123; width:100px; height:100px; background-color: red; &#125; .five-way&#123; width: -moz-fit-content; width: -webkit-fit-content; width: fit-content; margin: auto; &#125; .five-way &gt; div&#123; float:left; width:100px; height:100px; background-color: red; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first-way&quot;&gt; 第一种方式 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;second-way&quot;&gt; &lt;div class=&quot;second-child&quot;&gt;第二种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;third-way&quot;&gt; 第三种方式 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;fourth-way&quot;&gt; &lt;div&gt;第四种&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;/br&gt; &lt;div class=&quot;five-way&quot;&gt; &lt;div&gt; 第五种 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流式、响应布局]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E6%B5%81%E5%A4%B1%E5%B8%83%E5%B1%80%20%20%E5%93%8D%E5%BA%94%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[流式布局12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .parent &#123; width: 200px; height: 150px; background-color: black; display: flex; flex-wrap: wrap; align-content: flex-start; &#125; .child &#123; box-sizing: border-box; background-color: white; flex: 0 0 25%; height: 50px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style type=&quot;text/css&quot;&gt; .Grid &#123; display: flex;&#125;.Grid-cell &#123; flex: 0 0 0%;&#125;.Grid-cell.u-full &#123; flex: 0 0 100%;&#125;.Grid-cell.u-1of2 &#123; flex: 0 0 50%;&#125;.Grid-cell.u-1of3 &#123; flex: 0 0 33.3333%;&#125;.Grid-cell.u-1of4 &#123; flex: 2 0 25%;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;Grid&quot;&gt; &lt;div class=&quot;Grid-cell u-1of4&quot; style=&quot;background-color:red&quot;&gt;25%&lt;/div&gt; &lt;div class=&quot;Grid-cell&quot; style=&quot;background-color:red&quot;&gt;100%&lt;/div&gt; &lt;div class=&quot;Grid-cell u-1of2&quot; style=&quot;background-color:red&quot;&gt;50%&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三栏布局(双飞翼布局)]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%EF%BC%88%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;html,body&#123; height: 100%; margin: 0 ;&#125; /* float 关键是要把主体div放在最后，左右两栏div顺序任意。 代码足够简洁与高效 不足在于clear:both属性不能加在中间div上 */ .first div&#123; background-color: red; &#125; .first &gt; .left&#123; float: left; width: 100px; height: 100px; &#125; .first &gt; .right&#123; float: right; width: 100px; height: 100px; &#125; .first &gt; .middle&#123; margin:0 120px; height: 100px; &#125; /*position绝对定位 理解容易，上手简单，受内部元素影响而破坏布局的概率低 */ .second div&#123; background-color: green; &#125; .second &gt; .left,.second &gt; .right&#123; position: absolute; width:100px; height: 100px; top:120; /*默认应该为0*/ &#125; .second &gt; .left&#123;left:0;&#125; .second &gt; .right&#123;right: 0;&#125; .second &gt; .middle&#123;height: 100px;margin :0 120px;&#125; /*display:flex*/ .third&#123; display: flex; &#125; .third div&#123; background-color: #eee; &#125; .third &gt; .left,.third &gt; .right&#123; width:100px; height: 100px; &#125; .third &gt; .middle&#123; flex:1; margin: 0 10px; &#125; /* margin负值法 三栏相互关联，可谓真正意义上的自适应，布局不易受内部影响。 缺点在于：代码相对复杂。 原理:首先设置main的width为100%,然后三者float:left, 则按html顺序是main、left、right，此时由于main独占一行从而使得left和right换行显示。 再设置left的margin-left:-100%,使得left向左平移了100%width到达最左边并且左外边框与浏览器窗口重合，再令right的margin-left: -100px， 向左平移100px，最后设置body的margin: 0 120px,使得三者分开。 */ #main&#123; width: 100%; float: left; &#125; #main #body&#123; margin: 0 120px; background-color: black; &#125; #left,#right&#123; width:100px; height: 100%; float: left; background-color: black; &#125; #left&#123; margin-left: -100%; &#125; #right&#123; margin-left: -100px; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;div3&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; //写到最后 &lt;/div&gt;&lt;/br&gt; &lt;div class=&quot;second&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;div3&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; //写到最后 &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;third&quot;&gt; &lt;div id=&quot;div1&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;div2&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; &lt;div id=&quot;div3&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;fourth&quot;&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;body&quot; class=&quot;middle&quot;&gt;222&lt;/div&gt; //写到前面 &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;left&quot;&gt;111&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;right&quot;&gt;333&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水平垂直居中布局]]></title>
    <url>%2F2017%2F07%2F09%2FCSS%2F%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body,html&#123; height: 100%; &#125; .first-way&#123; height: 100%; display: flex; justify-content:center; &#125; .first-way &gt; div&#123; align-self:center; width:100px; height:100px; background-color: red; &#125; /* .second-way&#123; width:100%; height: 100%; position: relative; &#125; */ .second-way &#123; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:150px; height: 150px; border: 1px solid green; &#125; .third-way &gt; div&#123; position: absolute; top:0; left: 0; right: 0; bottom: 0; margin: auto; width: 200px; height: 200px; border: 1px solid black; &#125; .fourth-way&#123; position: absolute; left:50%; top:50%; width:250px; height: 250px; margin-top:-125px; margin-left: -125px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;first-way&quot;&gt; &lt;div&gt;第一种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second-way&quot;&gt; &lt;div &gt;第二种方式&lt;/div&gt; &lt;/div&gt; &lt;/br&gt; &lt;div class=&quot;third-way&quot;&gt; &lt;div&gt;第三种方式&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;fourth-way&quot;&gt; &lt;div&gt;第四种&lt;/div&gt; &lt;/div&gt; &lt;div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 缓存机制]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FHTML5%20Web%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[HTML5 之离线应用Manifest 在服务器上添加MIME TYPE支，让服务器能够识别manifest后缀的文件AddType text/cache-manifest manifest 创建一个后缀名为.manifest的文件，把需要缓存的文件按格式写在里面，并用注释行标注版本 CACHE MANIFEST # 直接缓存的文件 CACHE: Path/to/cache.js # version：2012-03-20 给 标签加 manifest 属性，并引用manifest文件 离线应用访问及更新流程： 第一次访问离线应用的入口页HTML（引用了manifest文件），正常发送请求，获取manifest文件并在本地缓存，陆续拉取manifest中的需要缓存的文件再次访问时，无论在线离线与否，都会直接从缓存中获取入口页HTML和其他缓存的文件进行展示。如果此时在线，浏览器会发送请求到服务器请求manifest文件，并与第一次访问的副本进行比对，如果发现版本不一致，会陆续发送请求重新拉取入口文件HTML和需要缓存的文件并更新本地缓存副本。之后的访问重复第2步的行为 离线机制的缓存用途： 从Manifest的机制来看，即使我们不是为了创建离线应用，也同样可以使用这种机制用于缓存文件，可以说是给Web缓存提供多一种可以选择的途径。 存在的问题：缓存文件更新控制不灵活就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。 HTML5 之本地存储localstorageHTML5给我们提供本地存储localstorage特性，严格来讲，其实已经不算传统Web缓存的范畴。因为它存储的地方是跟Web缓存分开的，是浏览器重新开辟的一个地方。 localstorage的作用本地存储localstorage的作用主要使Web页面能够通过浏览器提供的set/get接口，存储一些自定义的信息到本地硬盘，并且在单次访问或以后的访问过程中随时获取或修改。 Localstorage的使用Localstorage提供了几个非常易用的Api，setItem/getItem/removeItem/clear Localstorage的缓存用途Localstorage设计的本意可能是用来存储一些用户操作的个性化设置的文本类型的信息和数据，当我们其实也可能拿来当Web缓存区使用，比如我们可以将Base64格式编码的图片信息，存在localstorage中，再次访问时，直接本地获取后，使用Css3的Data:image的方式直接展现出来。 存在的问题：大小限制按照目前标准，目前浏览器只给每个独立的域名提供5m的存储空间，当存储超过5m，浏览器就会弹出警告框。]]></content>
      <categories>
        <category>网络</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML5缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web浏览器缓存机制]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FWeb%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、浏览器的缓存规则 从新鲜度和检验值两个维度来规定浏览器是否直接使用缓存中的副本还是重新获取资源。 新鲜度(过期机制，优先级高) Expires(过期日期) Cache-Control(max-age(多少秒数后过期) no-chahe(忽略缓存的副本而向服务器发送请求) no-store(强制缓存不要保留副本并直接向服务器发送请求) 不会发送请求到服务器去验证资源的新旧程度，满足任一即可： 含有完整的过期时间控制头信息（HTTP协议报文），并且仍在有效期内 浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度。 校验值(验证机制) Last-Modified（文件最后修改时间） ETag(文件标识，只要文件改变标识就会变化)(优先级高))第二次请求时会将If-Modified-Since或者If-None-Match发送给服务器验证资源的新旧程度 服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需要重新获取资源内容。 二、浏览器缓存的控制使用HTML Meta标签告诉页面忽略缓存副本，每次都向服务器请求资源，缓存代理器不支持，部分浏览器不支持 使用缓存相关的HTTP消息报头1.Cahce-Control与ExpiresCache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。 2.Last-Modified/ETag与Cache-control/Expries 配置Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，还是会发送请求到服务器询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器； Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（Etag）了。 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。 3.Last-Modified与ETag服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 三、哪些请求不能被缓存无法被浏览器缓存的请求： HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的 经过HTTPS安全加密的请求 POST请求无法被缓存 HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>浏览器缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存作用及类型]]></title>
    <url>%2F2017%2F07%2F08%2F%E7%BD%91%E7%BB%9C%2FWeb%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Web缓存的作用1.减少带宽消耗 2.降低服务器压力 3.减少网络时延 Web缓存的类型数据库数据缓存将查询的数据结果直接存储到内存中，下次查询时直接从内存中读取，提高响应效率。 服务器端缓存 代理服务器共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效。 CDN缓存。浏览器先向CDN边缘节点发起Web请求,若CDN节点中缓存的数据没有过期，则直接将数据返回到客户端，否则向源节点发送请求，获得数据之后更新CDN节点缓存的数据并返回到客户端 浏览器端缓存浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现 Web应用层缓存应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Web缓存类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定位]]></title>
    <url>%2F2017%2F07%2F07%2FCSS%2FCSS%20%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[相对定位 position:relative设置为相对定位的元素框会相对于正常位置偏移某个距离。元素仍然保持其未定位前的形状，它原本所占的空间仍保留。相对于的是元素之前的外边距(margin)左上角进行定位在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 position:absolute设置为绝对定位的元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素(最近的已定位的非static祖先元素)，或者是初始包含块(body或 HTML 元素)，如果这个元素没有设置left、top等定位值，则这个元素会像一个普通inline-block元素一样随着父元素移动，但其实已经脱离了文档流，只要设置了定位值就会展现出脱离文档流的效果。其一，无定位值的absolute元素可以使用margin定位；其二，无定位值的absolute元素是个没有实际宽度的浮动元素。其三，absolute相对父元素的内边距(padding)左上角进行定位 绝对定位 position:fixed生成绝对定位元素，该元素相对于浏览器窗口进行定位，元素的位置 通过left、top、right、bottom属性进行规定 浮动1float:&#123;left、right&#125;//浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 清除浮动1clear：&#123;left right both none&#125;//规定元素的哪一侧不允许其他浮动元素 clip、z-index只能在定位元素上有效left、top、right、bottom这4个属性值，它们都是配合position属性使用的，只有当position属性设置为 absolute、fixed、relative才有效，否则没有任何意义属性 | 描述—|—position| 把元素放置到一个静态的、相对的、绝对的、或固定的位置中。top| 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。right| 定义了定位元素右外边距边界与其包含块右边界之间的偏移。bottom| 定义了定位元素下外边距边界与其包含块下边界之间的偏移。left| 定义了定位元素左外边距边界与其包含块左边界之间的偏移。overflow| 设置当元素的内容溢出其区域时发生的事情,属性值有visible、hidden、scroll（剪掉但是会有滚动条以便查看）、auto。clip| 设置元素的形状。元素被剪入这个形状之中，然后显示出来，裁剪绝对定位元素。vertical-align| 设置元素的垂直对齐方式，适用于内联及 table-cell 元素。z-index| 设置元素的堆叠顺序,z-index属性只能应用于使用了绝对定位的元素。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS定位方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas Demo]]></title>
    <url>%2F2017%2F07%2F06%2FCSS%2FCanvas%2F</url>
    <content type="text"><![CDATA[简单的使用canvas1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function rectangle()&#123; var canvas = document.getElementById(&apos;rectangle&apos;); if(canvas == null) return false; var context = canvas.getContext(&quot;2d&quot;); context.fillStyle = &quot;red&quot;; context.strokeStyle = &quot;blue&quot;; context.fillRect(0,120,100,100);//x,y,width,height context.strokeRect(0,120,100,100); context.strokeStyle = &quot;rgba(255,0,0,0.2)&quot;; context.strokeRect(120,120,100,100); &#125; function circle()&#123; var canvas = document.getElementById(&apos;circle&apos;); if(canvas == null) return false; var context = canvas.getContext(&apos;2d&apos;); context.beginPath(); context.strokeStyle = &quot;blue&quot;; context.moveTo(100,100); //将路径的起点设置为圆心，闭合的时候才会闭合圆心 context.lineTo(200,100); //这句话写不写都没事 context.stroke(); context.arc(100, 100, 100,0, 1.5*Math.PI,true); //圆心（100,100），半径100，起始角0，结束角1.5PI，逆时针 //默认为false顺时针，true为逆时针，最右边为0*Math.PI，顺时针依次是0.5*Math.PI,1*Math.PI,1.5*Math.PI, context.closePath(); context.fillStyle = &apos;rgba(0,255,0,0.25)&apos;;//默认是黑色 context.fill(); //闭合的时候会找起点闭合，从而达到四分之一圆的效果 &#125; function line()&#123; var canvas = document.getElementById(&apos;line&apos;); if (canvas == null) return false; var context = canvas.getContext(&quot;2d&quot;); context.beginPath(); context.strokeStyle = &quot;rgb(250,0,0)&quot;; //和stroke()相对应 context.fillStyle = &quot;rgb(250,0,0)&quot; //和fill()相对应 //实验证明第一次lineTo的时候和moveTo功能一样，选择起点 context.lineTo(50, 100); //之后的lineTo会以上次lineTo的节点为开始，作为终点 context.lineTo(100, 100); context.stroke(); context.closePath(); context.beginPath(); //一定要有，不然第一条绘制的路径也会被绘制成第二个颜色 context.moveTo(100, 150); context.lineTo(200,150); context.strokeStyle = &quot;rgb(0,250,0)&quot;; context.stroke(); context.closePath(); &#125; window.onload = function()&#123; rectangle(); circle(); line(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;canvas id=&quot;rectangle&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt;&lt;/canvas&gt; &lt;/section&gt; &lt;section&gt; &lt;canvas id=&quot;circle&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt;&lt;/canvas&gt; &lt;/section&gt; &lt;section&gt; &lt;canvas id=&quot;line&quot; width=&quot;400px&quot; height=&quot;400px&quot;&gt;&lt;/canvas&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 参考：http://www.cnblogs.com/tim-li/archive/2012/08/06/2580252.html#top]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>canvas demo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种距离]]></title>
    <url>%2F2017%2F07%2F06%2FCSS%2FoffsetLeft%2CLeft%2CclientLeft%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[clientWidth：可见窗口clientWidth = width+padding-滚动条clientHeight = height+padding-滚动条 offsetWidth:元素自身offsetWidth = width+padding+borderoffsetHeight = height+padding+border scrollWidth:元素自身scrollWidth = width+padding+border+marginscrollHeight = height+padding+border+margin http://blog.csdn.net/xxb2008/article/details/9109329]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>offsetLeft</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3圆角]]></title>
    <url>%2F2017%2F07%2F05%2FCSS%2FCSS3%E5%9C%86%E8%A7%92%2F</url>
    <content type="text"><![CDATA[border-radius属性每个圆角存在”水平半径”（horizontal radius）和”垂直半径”（vertical radius）。border-radius可以同时设置1到4个值。如果设置1个值，表示4个圆角都使用这个值。如果设置两个值，表示左上角和右下角使用第一个值，右上角和左下角使用第二个值。如果设置三个值，表示左上角使用第一个值，右上角和左下角使用第二个值，右下角使用第三个值。如果设置四个值，则依次对应左上角、右上角、右下角、左下角（顺时针顺序）border-radius: 15px 5px;border-radius还可以用斜杠设置第二组值。这时，第一组值表示水平半径，第二组值表示垂直半径。第二组值也可以同时设置1到4个值，应用规则与第一组值相同。 1border-radius: 15px 5px / 3px;// 水平半径：15px 5px 15px 5px;垂直半径: 3px 3px 3px 3px 单个圆角的设置除了同时设置四个圆角以外，还可以单独对每个角进行设置。对应四个角，CSS3提供四个单独的属性：1234border-top-left-radiusborder-top-right-radiusborder-bottom-right-radiusborder-bottom-left-radius 这四个属性都可以同时设置1到2个值。如果设置1个值，表示水平半径与垂直半径相等。如果设置2个值，第一个值表示水平半径，第二个值表示垂直半径 浏览器支持IE 9+、Opera 10.5、Safari 5、Chrome 4和Firefox 4，都支持上述的border-radius属性。早期版本的Safari和Chrome，支持-webkit-border-radius属性，早期版本的Firefox支持-moz-border-radius属性。 目前来看，为了保证兼容性，只需同时设置-moz-border-radius和border-radius即可。12-moz-border-radius: 15px;border-radius: 15px; （注意：border-radius必须放在最后声明，否则可能会失效。） 另外，早期版本Firefox的单个圆角的语句，与标准语法略有不同。1234-moz-border-radius-topleft（标准语法：border-top-left-radius）-moz-border-radius-topright（标准语法：border-top-right-radius）-moz-border-radius-bottomleft（标准语法：border-bottom-left-radius）-moz-border-radius-bottomright（标准语法：border-bottom-right-radius） 摘自: 阮一峰大师的博客]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex布局]]></title>
    <url>%2F2017%2F07%2F04%2FCSS%2F%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B-flex%E5%B8%83%E5%B1%80%EF%BC%88%E6%89%BE%E6%97%B6%E9%97%B4%E5%8F%8D%E5%90%91%E5%AE%9E%E7%8E%B0%E7%AD%9B%E5%AD%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Flex布局flex布局一个容器指定为flex布局： 123.box&#123; display: flex; &#125; 行内元素也可以使用Flex布局。 12345678910.box&#123; display: inline-flex;&#125;.box&#123; display: -webkit-flex; /* Safari chrome*/ display: -moz-flex; /*firefox*/ display: -ms-flex; /*ie*/ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 基本概念采用flex布局的元素称为容器，其所有子元素称为容器成员，即为flex项目，容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end。交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 flex-direction1234567.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125;row(默认值)：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap123.box&#123; flex-wrap: nowrap(不换行) | wrap(换行) | wrap-reverse(换行，第一行在下方);&#125; flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-contentjustify-content属性定义了项目在主轴上的对齐方式。 12345678 .box &#123; justify-content: flex-start | flex-end | center | space-between | space-around; &#125;flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items定义项目在交叉轴上如何对齐。12345678 .box &#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125;flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123456789 .box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125;flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴 项目的属性order定义项目的排列顺序。数值越小，排列越靠前，默认为0。1234.item &#123; order: &lt;integer&gt;;&#125; flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。123.item &#123; flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]&#125; align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>布局方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[inline、block、inline-block之间的区别]]></title>
    <url>%2F2017%2F07%2F03%2FCSS%2Finline%E3%80%81block%E3%80%81inline-block%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[inline inline元素不会独占一行，多个相邻的行内元素在一行中排列，除非一行排列不下才会换一行，其高度随元素的内容而变化。 设置width、height属性无效 元素的margin、padding在水平方向会产生边距效果，但竖直方向不会。 block block元素独占一行，默认填满父元素宽度。 可以设置width、height、margin、padding属性 inline-block 将对象呈现为内联对象，内容作为块级元素对象呈现，在同一行，可设置高宽，比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 摘自：http://www.cnblogs.com/KeithWang/p/3139517.html]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>inline</tag>
        <tag>block</tag>
      </tags>
  </entry>
</search>